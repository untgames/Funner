#ifndef SCENE_GRAPH_MESH_HEADER
#define SCENE_GRAPH_MESH_HEADER

#include <sg/visual_model.h>

namespace scene_graph
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Статический меш
///////////////////////////////////////////////////////////////////////////////////////////////////
class StaticMesh: public VisualModel
{
  public:
    typedef xtl::com_ptr <StaticMesh> Pointer;
    typedef xtl::com_ptr <const StaticMesh> ConstPointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Pointer Create ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка имени меша модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        SetMeshName  (const char* name);
    const char* MeshName     () const;
    size_t      MeshNameHash () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка ограничивающий тел
///////////////////////////////////////////////////////////////////////////////////////////////////
    using VisualModel::SetBoundBox;
    using VisualModel::SetInfiniteBounds;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    StaticMesh  ();
    ~StaticMesh ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Метод, вызываемый при посещении данного объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Связывание свойств узла с методами узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindProperties (common::PropertyBindingMap& bindings);    

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об обновлении скин меша
///////////////////////////////////////////////////////////////////////////////////////////////////
enum SkinMeshEvent
{
  SkinMeshEvent_AfterJointNodesUpdate,    //срабатывает после обновления узлов соединений
  SkinMeshEvent_AfterJointMatricesUpdate, //срабатывает после обновления матриц соединений

  SkinMeshEvent_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Скин меш
///////////////////////////////////////////////////////////////////////////////////////////////////
class SkinMesh: public StaticMesh
{
  public:
    typedef xtl::com_ptr <SkinMesh> Pointer;
    typedef xtl::com_ptr <const SkinMesh> ConstPointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание модели
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Pointer Create ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с соединениями
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetJointsCount    (size_t count);
    size_t             JointsCount       () const;
    void               SetJointName      (size_t index, const char* name);
    void               SetJointInvMatrix (unsigned int index, const math::mat4f& inv_tm);
    Node::Pointer      Joint             (size_t index);
    Node::ConstPointer Joint             (size_t index) const;
    const char*        JointName         (size_t index) const;
    const math::mat4f& JointInvMatrix    (unsigned int index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события скин меша
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (SkinMesh& sender, SkinMeshEvent event_id)> EventHandler;

    xtl::connection RegisterEventHandler (SkinMeshEvent event_id, const EventHandler& event_handler);

    using Entity::RegisterEventHandler;

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SkinMesh  ();
    ~SkinMesh ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Метод, вызываемый при посещении данного объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AcceptCore (Visitor&);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Связывание свойств узла с методами узла
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindProperties (common::PropertyBindingMap& bindings);

  private:
    void OnChildNodeBind (Node& child);

  private:
    struct Impl;
    Impl* impl;
};

}

#endif
