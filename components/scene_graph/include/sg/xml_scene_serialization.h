#ifndef SCENE_GRAPH_XML_SCENE_SERIALIZATION_HEADER
#define SCENE_GRAPH_XML_SCENE_SERIALIZATION_HEADER

#include <sg/scene_manager.h>

namespace common
{

//forward declarations
class ParseNode;
class XmlWriter;

}

namespace scene_graph
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Прототип сцены, используемый для её создания
///////////////////////////////////////////////////////////////////////////////////////////////////
class ScenePrototype
{
  public:
    typedef xtl::function<void (Node& parent, SceneContext& scene_context)> CreateHandler;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////  
    ScenePrototype  (const CreateHandler& creator, const scene_graph::ResourceGroup& resources);
    ScenePrototype  (const ScenePrototype& prototype);
    ~ScenePrototype ();

    ScenePrototype& operator = (const ScenePrototype&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Группа ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    const scene_graph::ResourceGroup& Resources () const; //группа ресурсов данного прототипа
          scene_graph::ResourceGroup& Resources ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CreateScene (Node& parent, SceneContext& scene_context);
      ///??????????    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (ScenePrototype&);

  private:
    struct Impl;
    Impl* impl;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (ScenePrototype&, ScenePrototype&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сериализации узлов XML сцен
///////////////////////////////////////////////////////////////////////////////////////////////////
class XmlSceneSerializationManager
{
  public:
    typedef xtl::function<ScenePrototype (const common::ParseNode&)>       SceneLoader;
    typedef xtl::function<bool (common::XmlWriter& xml_write, Node& node)> SceneSaver;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация сериализаторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void RegisterLoader       (const char*        node_type,                             //имя типа узла
                                      const SceneLoader& loader,                                //загрузчик
                                      const char*        ignore_children_node_name_masks = ""); //имена вложенных узлов, которые будут проигнорированы при разборе дочерних узлов
    static void RegisterSaver        (const char* saver_name, const SceneSaver& saver);
    static void UnregisterLoader     (const char* node_type);
    static void UnregisterSaver      (const char* saver_name);
    static void UnregisterAllLoaders ();
    static void UnregisterAllSavers  ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация сериализаторов
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T> struct SuperClassLoader
    {
      typedef xtl::function<void (const common::ParseNode& parse_node, T& node)> Type;
    };

    template <class T> static void RegisterLoader   (const typename SuperClassLoader<T>::Type& loader);
    template <class T> static void UnregisterLoader ();
    
    template <class T> typename SuperClassLoader<T>::Type* FindLoader ();
};

}

#endif
