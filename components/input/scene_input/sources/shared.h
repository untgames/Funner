#include <stl/hash_map>
#include <stl/string>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/connection.h>
#include <xtl/function.h>
#include <xtl/trackable.h>
#include <xtl/token_parser.h>

#include <math/utility.h>

#include <bv/plane_list.h>

#include <common/singleton.h>

#include <sg/camera.h>
#include <sg/input.h>
#include <sg/scene.h>
#include <sg/screen.h>
#include <sg/viewport.h>

#include <input/scene_input.h>

namespace input
{

class InputScene;
class InputPort;

typedef xtl::intrusive_ptr<InputScene> InputScenePtr;

typedef bound_volumes::plane_list<float> frustum;

typedef size_t touch_t;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Состояние тача
///////////////////////////////////////////////////////////////////////////////////////////////////
enum TouchState
{
  TouchState_Moving,
  TouchState_Pressed,
  TouchState_Released
};

const touch_t MOUSE_TOUCH_ID = touch_t (~0);  //идентификатор тача мыши
const int     MOUSE_HOVER_ID = -1;            //идентификатор hover

///////////////////////////////////////////////////////////////////////////////////////////////////
///Событие нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TouchEvent
{
  touch_t     touch;      //идентификатор тача
  int         button;     //кнопка
  TouchState  state;      //состояние тача
  math::vec2f position;   //положение
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст обработки нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
struct TouchProcessingContext
{
  const TouchEvent&                         event;
  InputPort*                                input_port;
  xtl::com_ptr<scene_graph::InputZoneModel> input_zone;
  size_t                                    input_zone_index;
  float                                     intersection_distance;
  math::vec2f                               intersection_point;
  bool                                      touch_catched;
  
  TouchProcessingContext (const TouchEvent& in_event)
    : event (in_event)
    , input_port ()
    , input_zone ()
    , input_zone_index (~0u)
    , intersection_distance ()
    , intersection_point ()
    , touch_catched ()
  { }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Порт ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputPort: public xtl::reference_counter, public scene_graph::IViewportListener, public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputPort  (scene_graph::Viewport& in_viewport, bool& in_z_order_changed);
    ~InputPort ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    scene_graph::Viewport& AttachedViewport () { return viewport; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Активна ли область
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsActive () { return is_active; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработчики событий
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void OnViewportChangeArea       (const scene_graph::Rect& new_area, float min_depth_range, float max_depth_range);
    void OnViewportChangeCamera     (scene_graph::Camera* new_camera);
    void OnViewportChangeZOrder     (int);
    void OnViewportChangeActive     (bool new_state);
    void OnViewportChangeInputState (bool state);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размер тача
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetTouchSize (float size, InputTransformSpace);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FindTouch (TouchProcessingContext& touch_context, math::vec3f& out_touch_world_position);
    void OnTouch   (TouchProcessingContext& touch_context, const math::vec3f& touch_world_position);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс состояния нажатий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ResetTouchState ();

  private:
    void OnSceneChanged  ();
    void OnCameraUpdated ();
    void Update ();

  private:
    scene_graph::Viewport    viewport;               //область вывода
    bool&                    z_order_changed;        //порядок следования областей ввода изменен
    InputScenePtr            input_scene;            //сцена ввода
    bool                     is_active;              //активность области
    bool                     need_update;            //нужно обновление
    float                    touch_size;             //размер тача
    InputTransformSpace      touch_size_space;       //система координат размеров тача
    math::vec3f              touch_scale;            //коэффициент масштабирования тача
    xtl::auto_connection     on_camera_updated;      //соединение с событием обновления камеры
    xtl::auto_connection     on_scene_changed;       //соединение с событием изменения сцены
    math::mat4f              normalized_position_tm; //матрица преобразования координат (в систему координат проекции)
    math::mat4f              screen_tm;              //матрица преобразования координат (из мировой системы в систему координат экрана)
    math::mat4f              position_tm;            //матрица преобразования координат (в мировую систему координат)
    math::mat4f              view_proj_tm;           //матрица преобразования координат (proj * inv(view))
    frustum                  touch_frustum;          //пирамида тача
};

typedef xtl::intrusive_ptr<InputPort> InputPortPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Слушатель событий
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputEventListener: public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Список слушателей
///////////////////////////////////////////////////////////////////////////////////////////////////
    class List: public xtl::noncopyable
    {
      friend class InputEventListener;
      class Iterator;
      public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
        List  ();
        ~List ();
        
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение
///////////////////////////////////////////////////////////////////////////////////////////////////
        void BroadcastTouch (InputPort& input_port, const TouchEvent& event, const math::vec3f& touch_world_position);
        
///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление всех нажатий, связанных с указанной областью ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
        void RemoveAllTouches (InputPort&);
        
///////////////////////////////////////////////////////////////////////////////////////////////////
///Отсоединение всех
///////////////////////////////////////////////////////////////////////////////////////////////////
        void DetachAll ();

      private:
        InputEventListener* first;
        InputEventListener* last;
        Iterator*           first_iterator;
    };
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputEventListener ();
    virtual ~InputEventListener ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void OnBroadcastTouch (InputPort& input_port, const TouchEvent& event, const math::vec3f& touch_world_position) {}
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление всех нажатий, связанных с указанной областью ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void RemoveAllTouches (InputPort&) {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение слушателя к списку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Attach (List&);
    void Detach ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Является ли слушатель присоединенным
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsAttached () { return list != 0; }

  private:
    List*               list;
    InputEventListener* prev;
    InputEventListener* next;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Объект ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputEntity: public xtl::reference_counter, private InputEventListener
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputEntity  (const scene_graph::InputZoneModel& zone, InputScene& scene);
    ~InputEntity ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенная зона ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
    const scene_graph::InputZoneModel& Zone () { return zone; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события нажатия
///////////////////////////////////////////////////////////////////////////////////////////////////
    void OnTouch (InputPort& input_port, const TouchEvent& event, const math::vec3f& touch_world_position, size_t touch_zone_index, const math::vec2f& touch_local_position); 
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление всех нажатий, связанных с указанной областью ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RemoveAllTouches (InputPort&);
    
  private:
    struct TouchDesc
    {
      InputPort* port;
      touch_t    touch;
      int        button;      
      bool       is_inside;
      bool       touch_check;
      bool       on_touch_method_entered;
      
      TouchDesc (InputPort& in_port, touch_t in_touch, int in_button)
        : port (&in_port)
        , touch (in_touch)
        , button (in_button)
        , is_inside (true)
        , touch_check (false)
        , on_touch_method_entered (true)
       { }
    };
    
    typedef stl::vector<TouchDesc> TouchDescArray;
    
  private:
    void       OnBroadcastTouch    (InputPort& input_port, const TouchEvent& event, const math::vec3f& touch_world_position);
    void       UpdateNotifications ();
    void       UpdateBroadcasts    ();
    TouchDesc* AddTouch            (InputPort& port, touch_t touch, int button);
    TouchDesc* FindTouch           (InputPort& port, touch_t touch, int button);
    void       RemoveTouch         (InputPort& port, touch_t touch, int button);
    void       Notify              (InputPort& port, scene_graph::InputZoneNotification notification, const scene_graph::InputZoneNotificationContext& context);
  
  private:  
    const scene_graph::InputZoneModel& zone;
    InputScene&                        scene;
    xtl::auto_connection               on_notifications_changed_connection;
    bool                               has_screen_handlers;
    bool                               wait_for_release_event;
    TouchDescArray                     touches;
};

typedef xtl::intrusive_ptr<InputEntity> InputEntityPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отображение сцены ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputScene: public xtl::reference_counter, private InputEventListener::List
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputScene  (scene_graph::Scene& scene);
    ~InputScene ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединенная сцена
///////////////////////////////////////////////////////////////////////////////////////////////////
    scene_graph::Scene& Scene () { return scene; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение объекта ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputEntityPtr GetEntity (const scene_graph::InputZoneModel&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс состояния нажатий
///////////////////////////////////////////////////////////////////////////////////////////////////
    void ResetTouchState ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обработка события
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FindTouch (InputPort& input_port, const math::vec3f& touch_world_position, const math::vec3f& touch_world_direction, const frustum& touch_frustum, const math::mat4f& screen_tm, TouchProcessingContext& context);
    void OnTouch   (InputPort& input_port, const math::vec3f& touch_world_position, const TouchProcessingContext& context);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация слушателей оповещений
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterBroadcastListener (InputEventListener& listener);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление всех нажатий, связанных с указанной областью ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RemoveAllTouches (InputPort&);

  private:
    void OnInputZoneDestroyed (const scene_graph::InputZoneModel*);
    void OnInputZoneCreated   (scene_graph::Node&);
    
    struct EntityDesc
    {
      InputEntityPtr       entity;
      xtl::auto_connection on_unbind_connection;
    };
    
  private:
    typedef stl::hash_map<const scene_graph::InputZoneModel*, EntityDesc> EntityMap;

  private:    
    scene_graph::Scene&  scene;
    EntityMap            entities;
    xtl::auto_connection on_entity_created_connection;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Коллекция сцен ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputSceneCollection
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputSceneCollection  ();
    ~InputSceneCollection ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputScenePtr GetScene (scene_graph::Scene&);
    
  private:
    void OnSceneDestroyed (scene_graph::Scene*);    

  private:
    struct SceneDesc
    {
      InputScenePtr        scene;
      xtl::auto_connection on_scene_destroyed;
    };
  
    typedef stl::hash_map<scene_graph::Scene*, SceneDesc> InputSceneMap;    
    
  private:
    InputSceneMap scenes;
};

typedef common::Singleton<InputSceneCollection> InputSceneCollectionSingleton;

}
