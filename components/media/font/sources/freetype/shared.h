#ifndef MEDIA_FONT_FREETYPE_SHARED_HEADER
#define MEDIA_FONT_FREETYPE_SHARED_HEADER

#include <stl/hash_map>
#include <stl/string>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/common_exceptions.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/shared_ptr.h>

#include <math/vector.h>

#include <common/component.h>
#include <common/file.h>
#include <common/lockable.h>
#include <common/log.h>
#include <common/strlib.h>

#include <media/atlas_builder.h>
#include <media/charset_manager.h>
#include <media/font_library.h>
#include <media/rasterized_font.h>

#include <ft2build.h>
#include <ftglyph.h>
#include <ftstroke.h>
#include <freetype.h>

namespace media
{

namespace freetype
{

typedef xtl::uninitialized_storage<char>         DataBuffer;
typedef xtl::shared_ptr<DataBuffer>              DataBufferPtr;
typedef xtl::uninitialized_storage<unsigned int> CharCodesBuffer;

//////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека freetype
//////////////////////////////////////////////////////////////////////////////////////////////////
class FreetypeLibrary
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    FreetypeLibrary ();
    FreetypeLibrary (const FreetypeLibrary&);
    ~FreetypeLibrary ();

    FreetypeLibrary& operator = (const FreetypeLibrary&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Freetype API
///////////////////////////////////////////////////////////////////////////////////////////////////
    void    FT_Done_Face       (FT_Face face);
    void    FT_Done_Glyph      (FT_Glyph glyph);
    FT_UInt FT_Get_Char_Index  (FT_Face face, FT_ULong charcode);
    void    FT_Get_Glyph       (FT_GlyphSlot slot, FT_Glyph *aglyph);
    bool    FT_Get_Kerning     (FT_Face face, FT_UInt left_glyph, FT_UInt right_glyph, FT_UInt kern_mode, FT_Vector *akerning, bool nothrow = false);
    void    FT_Glyph_Stroke    (FT_Glyph *pglyph, FT_Stroker stroker, FT_Bool destroy);
    void    FT_Glyph_To_Bitmap (FT_Glyph* the_glyph, FT_Render_Mode render_mode, FT_Vector* origin, FT_Bool destroy);
    bool    FT_Load_Char       (FT_Face face, FT_ULong charcode, FT_Int32 load_flags, bool nothrow = false);
    void    FT_New_Memory_Face (const FT_Byte* file_base, FT_Long file_size, FT_Long face_index, FT_Face *aface);
    void    FT_Select_Charmap  (FT_Face face, FT_Encoding encoding);
    void    FT_Select_Size     (FT_Face face, FT_Int strike_index);
    void    FT_Set_Char_Size   (FT_Face face, FT_F26Dot6 char_width, FT_F26Dot6 char_height, FT_UInt horz_resolution, FT_UInt vert_resolution);
    void    FT_Stroker_Done    (FT_Stroker stroker);
    void    FT_Stroker_New     (FT_Stroker *astroker);
    void    FT_Stroker_Set     (FT_Stroker stroker, FT_Fixed radius, FT_Stroker_LineCap line_cap, FT_Stroker_LineJoin line_join, FT_Fixed miter_limit);
    void    FT_Glyph_Get_CBox  (FT_Glyph glyph, FT_UInt bbox_mode, FT_BBox *acbox);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (FreetypeLibrary&);

  private:
    struct Impl;
    Impl* impl;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Шрифт
//////////////////////////////////////////////////////////////////////////////////////////////////
class FreetypeFontDesc : public IFontDesc, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FreetypeFontDesc (const char* file_name);
    ~FreetypeFontDesc ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество шрифтов в наборе
///////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int FontsCount ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя гарнитуры / имя семейства / имя стиля
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* FamilyName (unsigned int index);
    const char* StyleName (unsigned int index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    Font CreateFont    (unsigned int index, const FontCreationParams& params);
    bool CanCreateFont (unsigned int index, const FontCreationParams& params);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчет ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef () { addref (this); }
    void Release () { release (this); }

 private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Шрифт free type
///////////////////////////////////////////////////////////////////////////////////////////////////
class FreetypeFace : public common::Lockable, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FreetypeFace (const DataBufferPtr& in_data, const FreetypeLibrary& in_library, unsigned int face_index);
    ~FreetypeFace ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///FreeType-дескриптор шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    FT_Face FaceHandle ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение ближайшего доступного размера шрифта, если такой не найден - возвращает 0
///////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int GetNearestFontSize (unsigned int size, unsigned int size_eps);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка размера шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetSize (unsigned int size, unsigned int horizontal_dpi, unsigned int vertical_dpi);

  private:
    FreetypeFace (const FreetypeFace&);             //no impl
    FreetypeFace& operator = (const FreetypeFace&); //no impl

  private:
    struct Impl;
    Impl* impl;
};

typedef xtl::intrusive_ptr<FreetypeFace> FreetypeFacePtr;

//////////////////////////////////////////////////////////////////////////////////////////////////
///Данные для растеризации шрифта
//////////////////////////////////////////////////////////////////////////////////////////////////
struct RasterizedFontParams : public xtl::reference_counter
{
  CharCodesBuffer                     utf32_charset;   //список символов
  xtl::uninitialized_storage<FT_UInt> ft_char_indices; //freetype индексы символов
  FontCreationParams                  font_params;     //параметры шрифта
  unsigned int                        choosen_size;    //выбранный размер шрифта
  FreetypeFacePtr                     face;            //шрифт
  FreetypeLibrary                     library;         //freetype библиотека
};

typedef xtl::intrusive_ptr<RasterizedFontParams> RasterizedFontParamsPtr;

//////////////////////////////////////////////////////////////////////////////////////////////////
///Растеризованный шрифт
//////////////////////////////////////////////////////////////////////////////////////////////////
class FreetypeRasterizedFont
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / копирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    FreetypeRasterizedFont (RasterizedFontParamsPtr font_params);
    FreetypeRasterizedFont (const FreetypeRasterizedFont& source);
    ~FreetypeRasterizedFont ();

    FreetypeRasterizedFont& operator = (const FreetypeRasterizedFont& source);

//////////////////////////////////////////////////////////////////////////////////////////////////
///Получение количества символов шрифта
//////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int GlyphsCount () const;

//////////////////////////////////////////////////////////////////////////////////////////////////
///Получение растеризованных глифов
//////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int          UniqueGlyphsCount () const;  //количество глифов с уникальными битмапами
    const unsigned int*   GlyphsMap         () const;  //соответствие глифа уникальному глифу (количество - GlyphsCount)
    const math::vec2ui*   GlyphsSizes       () const;  //размеры глифов (количество - UniqueGlyphsCount)
    const unsigned char** GlyphsBitmaps     () const;  //битовые карты глифов (8 битные монохромные) (количество - UniqueGlyphsCount)

//////////////////////////////////////////////////////////////////////////////////////////////////
///Создание растеризатора
//////////////////////////////////////////////////////////////////////////////////////////////////
    IFontRasterizer* operator () (const RasterizedFontCreationParams& params);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (FreetypeRasterizedFont&);

  private:
    struct Impl;
    Impl* impl;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Растеризатор шрифта
//////////////////////////////////////////////////////////////////////////////////////////////////
class FreetypeFontRasterizer : public IFontRasterizer, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FreetypeFontRasterizer (const RasterizedFontCreationParams& params, const FreetypeRasterizedFont& rasterized_font);
    ~FreetypeFontRasterizer ();

//////////////////////////////////////////////////////////////////////////////////////////////////
///Получение информации о растрированных символах
//////////////////////////////////////////////////////////////////////////////////////////////////
    const RasterizedGlyphInfo* RasterizedGlyphs ();

//////////////////////////////////////////////////////////////////////////////////////////////////
///Построение картинок
//////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int ImagesCount ();
    void         BuildImage  (unsigned int image_index, media::Image& out_image);

//////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчет ссылок
//////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef () { addref (this); }
    void Release () { release (this); }

  private:
    struct Impl;
    Impl* impl;
};

//Обводчик глифов
class FreetypeStroker
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FreetypeStroker (const FreetypeLibrary& in_library, unsigned int stroke_size);
    ~FreetypeStroker ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение обводичка
///////////////////////////////////////////////////////////////////////////////////////////////////
    FT_Stroker Stroker () { return stroker; }

  private:
    FreetypeStroker (const FreetypeStroker&);             //no impl
    FreetypeStroker& operator = (const FreetypeStroker&); //no impl

  private:
    FreetypeLibrary library;  //библиотека
    FT_Stroker      stroker;  //обводчик
};

//Получение имени ошибки free type
const char* get_free_type_error_name (FT_Error error);

//Проверка ошибки free type
void check_free_type_error (FT_Error error, const char* source);

}

}

#endif
