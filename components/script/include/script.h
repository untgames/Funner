#ifndef SCRIPT_HEADER
#define SCRIPT_HEADER

#include <xtl/functional_fwd>
#include <common/exception.h>

//forward declarations
struct lua_State;

namespace script
{

namespace lua
{

//implementation forwards
namespace detail
{

class Invoker;

}

//////////////////////////////////////////////////////////////////////////////////////////////////
///Элемент стека
//////////////////////////////////////////////////////////////////////////////////////////////////
class StackItem
{
  public:
    StackItem (lua_State*, size_t);

/////////////////////////////////////////////////////////////////////////////////////////////////
///Взятие значения аргумента
//////////////////////////////////////////////////////////////////////////////////////////////////
    operator float       () const;
    operator double      () const;
    operator int         () const;
    operator size_t      () const;
    operator const char* () const;
    operator const void* () const;

    template <class T> operator T () const;
    
  private:
    struct lua_State* state;
    size_t            argument_number;
};  

//////////////////////////////////////////////////////////////////////////////////////////////////
///Стек аргументов
//////////////////////////////////////////////////////////////////////////////////////////////////
class Stack
{
  public:
    Stack (lua_State*);
    
    typedef StackItem Item;
    
//////////////////////////////////////////////////////////////////////////////////////////////////
///Количество элементов в стеке
//////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size () const;
    int    CheckAvailable (size_t count) const;

//////////////////////////////////////////////////////////////////////////////////////////////////
///Получение элемента из стека
//////////////////////////////////////////////////////////////////////////////////////////////////
    Item Get (int item_number) const;
    
    template <class T> T Get (int item_number) const;

//////////////////////////////////////////////////////////////////////////////////////////////////
///Помещение данных в стек
//////////////////////////////////////////////////////////////////////////////////////////////////
    void Push (double);
    void Push (int);
    void Push (const char*);
    void Push (void*);
    
    template <class T>
    void Push (const T&);

    void PushFunction (const char* f_name);

    void* Alloc (size_t size);                       //выделение блока памяти
//////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление элементов стека
//////////////////////////////////////////////////////////////////////////////////////////////////
    void Pop (size_t);

  private:
    lua_State* state;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Скриптовая среда
//////////////////////////////////////////////////////////////////////////////////////////////////
class Environment
{
  public:
    Environment  ();
    ~Environment ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка пользовательской функции лога дебаг-сообщений
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (const char* env_name, const char* message)> DebugLogFunc;

    void SetDebugLog (const DebugLogFunc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя среды
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Name   () const;
    void        Rename (const char* new_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получене стека
///////////////////////////////////////////////////////////////////////////////////////////////////
          lua::Stack* Stack ();
    const lua::Stack* Stack () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Биндинг функций
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class Signature, class Fn> void BindFunction (const char* name, Fn fn);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Выполнение команды луа
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Invoke   (size_t args_count, size_t results_count);
    void DoString (const char* expression);
    void DoFile   (const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Environment&);

  private:
    void RegisterFunction (const char* name, detail::Invoker* invoker);

  private:
    struct Impl;
    
    Impl* impl;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
//////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Environment&, Environment&);

//////////////////////////////////////////////////////////////////////////////////////////////////
///Вызов функций луа
//////////////////////////////////////////////////////////////////////////////////////////////////
template <class Ret>
Ret invoke (Environment&, const char* fn_name);

template <class Ret, class T1>
Ret invoke (Environment&, const char* fn_name, const T1& arg1);

template <class Ret, class T1, class T2>
Ret invoke (Environment&, const char* fn_name, const T1& arg1, const T2& arg2);

#include <detail/script.inl>

}

}

#endif
