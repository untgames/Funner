#ifndef SCRIPTLIB_INVOKER_HEADER
#define SCRIPTLIB_INVOKER_HEADER

#include <xtl/functional_fwd>
#include <xtl/type_info_decl.h>

#include <stl/auto_ptr.h>

#include <script/stack.h>

namespace xtl
{

//forward declarations
template <class T> class iterator;

}

namespace script
{

//forward declaration
class Environment;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция-шлюз между скриптовым движком и C++ кодом
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef xtl::function<size_t (IStack&)> Invoker; //return results count in stack

///////////////////////////////////////////////////////////////////////////////////////////////////
///События реестра шлюзов
///////////////////////////////////////////////////////////////////////////////////////////////////
enum InvokerRegistryEvent
{
  InvokerRegistryEvent_OnRegisterInvoker,    //срабатывает при добавлении шлюза
  InvokerRegistryEvent_OnUnregisterInvoker,  //срабатывает при удалении шлюза
  
  InvokerRegistryEvent_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реестр шлюзов
///////////////////////////////////////////////////////////////////////////////////////////////////
class InvokerRegistry
{
  public:
    typedef xtl::iterator<Invoker>       Iterator;
    typedef xtl::iterator<const Invoker> ConstIterator;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InvokerRegistry  ();
    InvokerRegistry  (const InvokerRegistry&);
    ~InvokerRegistry ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    InvokerRegistry& operator = (const InvokerRegistry&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск шлюза по имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    const Invoker* Find (const char* name) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение итератора
///////////////////////////////////////////////////////////////////////////////////////////////////
    Iterator      CreateIterator ();
    ConstIterator CreateIterator () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение идентификатора шлюза
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* InvokerId (const ConstIterator&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация/удаление шлюзов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Register   (const char* name, const Invoker& invoker);       
    void Register   (const InvokerRegistry& registry); //регистрация копий шлюзов registry        
    void Register   (const Environment& environment, const char* registry_name); //регистрация копий шлюзов registry
    void Register   (const char* name, const char* source_name); //регистрация копии
    void Register   (const char* name, const InvokerRegistry& source_registry, const char* source_name); //регистрация копии
    void Unregister (const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Очистка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Clear ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация обработчиков событий
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (InvokerRegistryEvent, const char* invoker_name, Invoker& invoker)> EventHandler;

    xtl::connection RegisterEventHandler (InvokerRegistryEvent event_id, const EventHandler& handler) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (InvokerRegistry&);
  
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (InvokerRegistry&, InvokerRegistry&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дескриптор шлюза
///////////////////////////////////////////////////////////////////////////////////////////////////
class InvokerDeclaration
{
  public:  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    InvokerDeclaration  (const Invoker&);
    InvokerDeclaration  (const InvokerDeclaration&);
    ~InvokerDeclaration ();

    InvokerDeclaration& operator = (const InvokerDeclaration&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип возвращаемого значения
///////////////////////////////////////////////////////////////////////////////////////////////////
    const xtl::type_info& ResultType () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t ParametersCount () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение параметра
///////////////////////////////////////////////////////////////////////////////////////////////////
    const xtl::type_info& ParameterType (size_t index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество перегрузок
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t OverloadsCount () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение перегрузки
///////////////////////////////////////////////////////////////////////////////////////////////////    
    InvokerDeclaration Overload (size_t index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (InvokerDeclaration&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (InvokerDeclaration&, InvokerDeclaration&);

}

#endif
