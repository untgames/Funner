#ifndef COMMONLIB_STREAMS_HEADER
#define COMMONLIB_STREAMS_HEADER

#include <stl/auto_ptr.h>
#include <xtl/functional_fwd>
#include <common/exception.h>

namespace stl
{

//forward declarations
template <class Char, class Traits, class Allocator> class basic_string;

}

namespace common
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер потоков вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputStreamBuffer
{
  public:
    enum { DEFAULT_BUFFER_SIZE = 8192 };
    
    typedef xtl::function<size_t (const void* buffer, size_t buffer_size)> WriteFunction;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    OutputStreamBuffer  (size_t buffer_size = DEFAULT_BUFFER_SIZE);
    OutputStreamBuffer  (const WriteFunction& writer, size_t buffer_size = DEFAULT_BUFFER_SIZE);
    ~OutputStreamBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Запись
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Write (const void* buffer, size_t size);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление размером буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size   () const;
    void   Resize (size_t buffer_size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение пользовательского буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUserBuffer (void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция записи данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetWriter (const WriteFunction&);
    const WriteFunction& Writer    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция записи данных по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t DefaultWriter (const void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Flush ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (OutputStreamBuffer&);

  private:
    OutputStreamBuffer (const OutputStreamBuffer&); //no impl
    OutputStreamBuffer& operator = (const OutputStreamBuffer&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (OutputStreamBuffer&, OutputStreamBuffer&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер потоков ввода
///////////////////////////////////////////////////////////////////////////////////////////////////
class InputStreamBuffer
{
  public:
    enum { DEFAULT_BUFFER_SIZE = 8192 };
    
    typedef xtl::function<size_t (void* buffer, size_t buffer_size)> ReadFunction;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    InputStreamBuffer  (size_t buffer_size = DEFAULT_BUFFER_SIZE);
    InputStreamBuffer  (const ReadFunction& reader, size_t buffer_size = DEFAULT_BUFFER_SIZE);
    ~InputStreamBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Read (void* buffer, size_t size);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление размером буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Size   () const;
    void   Resize (size_t buffer_size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение пользовательского буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetUserBuffer (void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция чтения данных
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                SetReader (const ReadFunction&);
    const ReadFunction& Reader    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Функция чтения данных по умолчанию
///////////////////////////////////////////////////////////////////////////////////////////////////
    static size_t DefaultReader (void* buffer, size_t size);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (InputStreamBuffer&);

  private:
    InputStreamBuffer (const InputStreamBuffer&); //no impl
    InputStreamBuffer& operator = (const InputStreamBuffer&); //no impl    

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (InputStreamBuffer&, InputStreamBuffer&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Исключение: невозможно записать в поток
///////////////////////////////////////////////////////////////////////////////////////////////////
struct StreamWriteExceptionTag;

typedef DerivedException<Exception, StreamWriteExceptionTag> StreamWriteException;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текстовый поток вывода (выход потока в UTF8)
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputTextStream
{
  public:
    typedef OutputStreamBuffer::WriteFunction WriteFunction;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    OutputTextStream  (size_t buffer_size = OutputStreamBuffer::DEFAULT_BUFFER_SIZE);
    OutputTextStream  (const WriteFunction& writer, size_t buffer_size = OutputStreamBuffer::DEFAULT_BUFFER_SIZE);
    ~OutputTextStream ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер потока
///////////////////////////////////////////////////////////////////////////////////////////////////
    const OutputStreamBuffer& Buffer () const;
          OutputStreamBuffer& Buffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод строк (базовая гарантия исключений)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Write (const char* string);
    void Write (const char* string, size_t length);
    void Write (const wchar_t* string);
    void Write (const wchar_t* string, size_t length);

  private:
    OutputTextStream (const OutputTextStream&); //no impl
    OutputTextStream& operator = (const OutputTextStream&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод строк
///////////////////////////////////////////////////////////////////////////////////////////////////
void write (OutputTextStream&, const char* string);
void write (OutputTextStream&, const wchar_t* string);

template <class Traits, class Allocator>
void write (OutputTextStream&, const stl::basic_string<char, Traits, Allocator>&);

template <class Traits, class Allocator>
void write (OutputTextStream&, const stl::basic_string<wchar_t, Traits, Allocator>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод символов
///////////////////////////////////////////////////////////////////////////////////////////////////
void write (OutputTextStream&, char symbol);
void write (OutputTextStream&, signed char symbol);
void write (OutputTextStream&, unsigned char symbol);
void write (OutputTextStream&, wchar_t symbol);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод целых чисел
///  format:
///    ""      - вывод с форматированием по умолчанию
///    "hex"   - вывод в шестнадцатиричном формате
///    "#"     - вывод с заполнителем по умолчанию (' ') и шириной не меньше 1
///    "000"   - вывод с заполнителем 0 и шириной 3
///    "+##"   - вывод с заполнителем по умолчанию, шириной 3 и указанием знака
///    "hex:#" - вывод с заполнителем по умолчанию, шириной 1 в шастнадцатиричном формате
///////////////////////////////////////////////////////////////////////////////////////////////////
    //сделать проверку формата!!!
void write (OutputTextStream&, int value, const char* format="");
void write (OutputTextStream&, unsigned int value, const char* format="");

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод чисел с плавающей точкой
///  format (аналогично целым числам, исключая системы счисления):
///    отсутствие точки - печать дробной части с форматированием по умолчанию
///    ".##" - ширина не больше 2-х (1.2=1.2, 1.211=1.2)
///    ".00" - ширина 2 (1.2=1.20, 1.211=1.21)
///////////////////////////////////////////////////////////////////////////////////////////////////
    //сделать проверку формата!!!
void write (OutputTextStream&, float value, const char* format="");
void write (OutputTextStream&, double value, const char* format="");
void write (OutputTextStream&, long double value, const char* format="");

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод логических значений
///  format:
///    "alpha" - вывод в текстовом виде (true, false)
///    ""      - вывод в численном виде (0, 1)
///////////////////////////////////////////////////////////////////////////////////////////////////
void write (OutputTextStream&, bool value, const char* format);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вывод интервалов
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class InIter>
void write_range (OutputTextStream&, InIter first, InIter last, const char* format="", const char* separator=" ");

template <class InIter>
void write_range (OutputTextStream&, InIter first, InIter last, const char* format, const wchar_t* separator);

#include <common/detail/streams.inl>

}

#endif
