#ifndef COMMONLIB_SINGLEON_HEADER
#define COMMONLIB_SINGLEON_HEADER

#include <cstdlib>
#include <new>
#include <typeinfo>

#include <stl/stdexcept>

#include <common/lockable.h>

namespace common
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Распределение памяти для синглтона при помощи new/delete
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct SingletonCreateUsingNew
{
  static T*   Create  ();
  static void Destroy (T*);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Распределение памяти для синглтона при помощи malloc/free
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct SingletonCreateUsingMalloc
{
  static T*   Create  ();
  static void Destroy (T*);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размещение синглтона в статической памяти
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct SingletonStatic
{
  static T*   Create  ();
  static void Destroy (T*);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размещение не удаляемого синглтона в статической памяти
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct SingletonStaticNoDestroy
{
  static T*   Create  ();
  static void Destroy (T*);
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Протоколирование синглтонов
///////////////////////////////////////////////////////////////////////////////////////////////////
class SingletonLog
{
  public:
    enum Event
    {
      Event_BeforeCreate,  //перед созданием экземпляра
      Event_AfterCreate,   //после создания экземпляра
      Event_BeforeDestroy, //перед удалением экземпляра
      Event_AfterDestroy,  //после удаления экземпляра
    };
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о событиях синглтонов
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void LogEvent (Event event, const std::type_info& type);    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка функции протоколирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef void (*LogHandler)(Event event, const std::type_info& type);

    static void       SetLogHandler (LogHandler handler);
    static LogHandler GetLogHandler ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочная функция протоколирования
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void DebugLogHandler (Event event, const std::type_info& type);
    
  private:
    static LogHandler log_handler;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел списка синглтонов
///////////////////////////////////////////////////////////////////////////////////////////////////
class SingletonListNode
{
  template <class T,template <class> class CreationPolicy> friend class Singleton;
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация активных синглтонов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterSingleton   (const std::type_info&, void (*destroy_function)());
    void UnregisterSingleton ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Уничтожение всех синглтонов
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void DestroyAll ();

  private:
    SingletonListNode*        prev;
    SingletonListNode*        next;
    void                      (*destroy_function)();
    const std::type_info*     type;
    static SingletonListNode* first;
    static bool               atexit_registered;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс поддержки объекта - одиночки
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T,template <class> class CreationPolicy=SingletonStatic>
class Singleton
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс блокировки экземпляра
///////////////////////////////////////////////////////////////////////////////////////////////////
    class Instance
    {
      public:
        Instance  ();
        Instance  (const Instance&);
        ~Instance ();

        T* operator -> () const;
        T& operator *  () const;
    };
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Инициализирован ли синглтон
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool IsInitialized ();
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Явная инициализация / уничтожение
///////////////////////////////////////////////////////////////////////////////////////////////////
    static void Init    ();
    static void Destroy ();    

  private:
    Singleton ();

  private:
    static T*                instance;
    static Lockable          lockable;
    static SingletonListNode node;
    static bool              is_in_init;
};

#include <common/detail/singleton.inl>

}

#endif
