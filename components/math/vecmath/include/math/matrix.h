#ifndef MATHLIB_VECMATH_MATRIX_HEADER
#define MATHLIB_VECMATH_MATRIX_HEADER

#include <math/vector.h>

#ifdef _MSC_VER  
  #pragma pack(push,1)
#endif

#ifdef minor
#undef minor
#endif

namespace math
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Matrix
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, unsigned int Size>
class matrix
{
  public:
    typedef math::vector<T, Size>       vector;     //row vector
    typedef typename vector::value_type value_type; //element type
    
    enum { size = Size };

///////////////////////////////////////////////////////////////////////////////////////////////////
///Constructors
///////////////////////////////////////////////////////////////////////////////////////////////////
    matrix ();
    matrix (const value_type& a);      //a will be assigned to main diagonal
    matrix (const value_type* values); //values - array of matrix values

      //For using return value optimization
    template <class T1, class Fn>                     matrix (const T1& arg, Fn fn, return_value_tag);                  //fn (arg, *this)
    template <class T1, class T2, class Fn>           matrix (const T1& arg1, const T2& arg2, Fn fn, return_value_tag); //fn (arg1, arg2, *this)
    template <class T1, class T2, class T3, class Fn> matrix (const T1& arg1, const T2& arg2, const T3& arg3, Fn fn, return_value_tag); //fn (arg1, arg2, arg3, *this)

///////////////////////////////////////////////////////////////////////////////////////////////////
///Indexing
///////////////////////////////////////////////////////////////////////////////////////////////////
          vector& row         (unsigned int index);
    const vector& row         (unsigned int index) const;
          vector  column      (unsigned int index) const; //copy!
          vector& operator [] (unsigned int index);
    const vector& operator [] (unsigned int index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Unary operators
///////////////////////////////////////////////////////////////////////////////////////////////////
    const matrix& operator + () const;
          matrix  operator - () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Assignment
///////////////////////////////////////////////////////////////////////////////////////////////////
    matrix& operator = (const value_type&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Basic arithmetic operators
///////////////////////////////////////////////////////////////////////////////////////////////////
    matrix& operator += (const matrix&);
    matrix& operator -= (const matrix&);
    matrix& operator *= (const value_type&);
    matrix& operator /= (const value_type&);
    matrix& operator *= (const matrix&);
    matrix  operator +  (const matrix&) const;
    matrix  operator -  (const matrix&) const;
    matrix  operator *  (const value_type&) const;
    matrix  operator /  (const value_type&) const; 
    matrix  operator *  (const matrix&) const; 

///////////////////////////////////////////////////////////////////////////////////////////////////
///Multiplication by vector (matrix is a row, vector is a column)
///////////////////////////////////////////////////////////////////////////////////////////////////
    vector                  operator * (const vector&) const;
    math::vector<T, Size-1> operator * (const math::vector<T, Size-1>&) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Comparison
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const matrix&) const;
    bool operator != (const matrix&) const;

  private:
    vector x [size];  
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Types definition
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef matrix<float, 2>  mat2f;
typedef matrix<float, 3>  mat3f;
typedef matrix<float, 4>  mat4f;
typedef matrix<double, 2> mat2d;
typedef matrix<double, 3> mat3d;
typedef matrix<double, 4> mat4d;
typedef matrix<int, 2>    mat2i;
typedef matrix<int, 3>    mat3i;
typedef matrix<int, 4>    mat4i;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Multiplication by scalar
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, unsigned int Size>
matrix<T, Size> operator * (const T& a, const matrix<T, Size>& m);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Multiplication of vector-row by matrix-column
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, unsigned int Size>
vector<T, Size> operator * (const vector<T, Size>& v, const matrix<T, Size>& m);

template <class T, unsigned int Size>
vector<T, Size> operator * (const vector<T, Size>& v, const matrix<T, Size+1>& m);

template <class T, unsigned int Size>
vector<T, Size>& operator *= (vector<T, Size>& v, const matrix<T, Size>& m);

template <class T, unsigned int Size>
vector<T, Size>& operator *= (vector<T, Size>& v, const matrix<T, Size+1>& m);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get transposed matrix
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, unsigned int Size>
matrix<T, Size> transpose (const matrix<T, Size>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get inverse matrix
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, unsigned int Size>
matrix<T, Size> inverse (const matrix<T, Size>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get normalized matrix
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, unsigned int Size>
matrix<T, Size> normalize (const matrix<T, Size>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Calculate matrix determinant (for square matrix)
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, unsigned int Size> 
typename matrix<T, Size>::value_type det (const matrix<T, Size>&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Minor
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, unsigned int Size>
typename matrix<T, Size>::value_type minor (const matrix<T, Size>&, unsigned int, unsigned int);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Comparison
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T, unsigned int Size> 
bool equal (const matrix<T, Size>&, const matrix<T, Size>&, const T& eps);

#include <math/detail/matrix.inl>

}

#ifdef _MSC_VER
  #pragma pack(pop)
#endif

#endif
