#ifndef SOCIAL_SESSION_MANAGER_HEADER
#define SOCIAL_SESSION_MANAGER_HEADER

#include <cstddef>

#include <xtl/functional_fwd>

namespace common
{

//forward declaration
class PropertyMap;

}

namespace social
{

enum OperationStatus
{
  OperationStatus_Success,
  OperationStatus_Failure
};

//forward declaration
class IUser;

/*///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип результата выполнения операции
///////////////////////////////////////////////////////////////////////////////////////////////////
template <class T> struct RequestResultType       { typedef T&   Type; };
template <>        struct RequestResultType<void> { typedef void Type; };

/*struct RequestResult
{
  const std::type_info* type;

  RequestResult (const std::type_info& in_type)
    : type (&in_type)
    {}
};*/

/*///////////////////////////////////////////////////////////////////////////////////////////////////
///Результат выполнения операции
///////////////////////////////////////////////////////////////////////////////////////////////////
class RequestState
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class T>
    RequestState  (const T& result);
    RequestState  (OperationStatus status, const char* error);
    RequestState  (const RequestState&);
    ~RequestState ();

    RequestState& operator = (const RequestState&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение результата
///////////////////////////////////////////////////////////////////////////////////////////////////
    template <class Ret> typename RequestResultType<Ret>::Type Value () const;

    xtl::any AnyValue () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение состояния
///////////////////////////////////////////////////////////////////////////////////////////////////
    OperationStatus Status () const;
    const char*     Error  () const;

  private:
    struct Impl;
    Impl* impl;
};*/

/*template <class T>
class RequestStateImpl : private RequestResult, public RequestState
{
  public:
    RequestStateImpl (const T& in_result)
      : RequestResult (typeid (T))
      , RequestState (*this, OperationStatus_Success, "")
      , result (in_result)
    {
    }

    RequestStateImpl (OperationStatus status, const char* error);

    xtl::any AnyValue () const
    {
      return xtl::any (result, true);
    }

  private:
    T result;
};*/

//typedef xtl::function<void (const RequestState& state)> RequestCallback;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сессия
///////////////////////////////////////////////////////////////////////////////////////////////////
class Session
{
  public:
    typedef xtl::com_ptr<Session> Pointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание сессии
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual const char* GetDescription () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Логин
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void LogIn      (const common::PropertyMap& config) = 0;
    virtual void LogOut     () = 0;
    virtual bool IsLoggedIn () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение залогиненного пользователя
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual User& CurrentUser () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка пользователя по идентификатору
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (const User& user, OperationStatus status, const char* error)> LoadUserCallback;

    virtual void LoadUser (const char* id, const LoadUserCallback& callback) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Аватар
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (const media::Image& picture, OperationStatus status, const char* error)> LoadPictureCallback;

    virtual void LoadUserPicture (const char* id, const LoadPictureCallback& callback) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Друзья
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<void (size_t count, const char** users, OperationStatus status, const char* error)> LoadFriendsIdsCallback;
    typedef xtl::function<void (size_t count, IUser** users, OperationStatus status, const char* error)>      LoadFriendsCallback;

    virtual void LoadFriendsIds (const char* id, const LoadFriendsIdsCallback& callback) = 0;
    virtual void LoadFriends    (const char* id, const LoadFriendsCallback& callback) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void AddRef  () = 0;
    virtual void Release () = 0;

  protected:
    virtual ~ISession () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер сессий
///////////////////////////////////////////////////////////////////////////////////////////////////
class SessionManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация создателей сессий
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef xtl::function<Session* ()> CreateSessionHandler;

    static void RegisterSession       (const char* name, const CreateSessionHandler& handler);
    static void UnregisterSession     (const char* name);
    static void UnregisterAllSessions ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия сессии
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool HasSession (const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание сессии по имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Session::Pointer CreateSession (const char* name);
};

}

#endif
