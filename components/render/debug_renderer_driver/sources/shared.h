#ifndef RENDER_MID_LEVEL_DEBUG_DRIVER_SHARED_HEADER
#define RENDER_MID_LEVEL_DEBUG_DRIVER_SHARED_HEADER

#include <stl/algorithm>
#include <stl/list>
#include <stl/vector>

#include <xtl/reference_counter.h>
#include <xtl/function.h>
#include <xtl/string.h>
#include <xtl/common_exceptions.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/iterator.h>

#include <common/log.h>
#include <common/component.h>

#include <media/compressed_image.h>
#include <media/image.h>

#include <render/mid_level/driver.h>
#include <render/mid_level/renderer2d.h>

#ifdef _MSC_VER
  #pragma warning (disable : 4250) //'class1' : inherits 'class2::member' via dominance
#endif

namespace render
{

namespace mid_level
{

namespace debug
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Константы
///////////////////////////////////////////////////////////////////////////////////////////////////
const size_t SCREEN_WIDTH  = 800; //ширина внутреннего экрана
const size_t SCREEN_HEIGHT = 600; //высота внутреннего экрана

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый объект
///////////////////////////////////////////////////////////////////////////////////////////////////
class Object: virtual public IObject, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Object ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();    
    void Release ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Идентификатор
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t Id () const { return id; }

  protected:
    common::Log log;
    
  private:
    size_t id;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип целевого буфера отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
enum RenderTargetType
{
  RenderTargetType_Color,        //буфер цвета
  RenderTargetType_DepthStencil, //буфер попиксельного отсечения
  
  RenderTargetType_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевой буфер отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTarget: virtual public IRenderTarget, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTarget (size_t width, size_t height, RenderTargetType type);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип целевого буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetType GetType () { return type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Размеры буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetWidth  ();
    size_t GetHeight ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование образа текстуры в картинку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CaptureImage (media::Image&);
    
  private:
    size_t           width, height;
    RenderTargetType type;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderBuffer: public RenderTarget
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderBuffer  (size_t width, size_t height, RenderTargetType type);
    ~RenderBuffer ();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class FrameBuffer: virtual public IFrameBuffer, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    FrameBuffer  ();
    ~FrameBuffer ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение буфера цвета и буфера попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderTarget* GetColorBuffer        ();
    IRenderTarget* GetDepthStencilBuffer ();
    
  private:
    typedef xtl::com_ptr<IRenderTarget> RenderTargetPtr;

  private:
    RenderTargetPtr color_buffer;
    RenderTargetPtr depth_stencil_buffer;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовая реализация кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class BasicFrame: virtual public IFrame, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BasicFrame ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевые буферы отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void           SetRenderTargets      (IRenderTarget* render_target, IRenderTarget* depth_stencil_target);
    IRenderTarget* GetRenderTarget       (); //целевой буфер цвета
    IRenderTarget* GetDepthStencilTarget (); //целевой буфер попиксельного отсечения

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewport (const Viewport&);
    void GetViewport (Viewport&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Визуализация
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw ();
    
  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void BindViewport ();
    
  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void DrawCore () = 0;

  private:
    typedef xtl::com_ptr<RenderTarget> RenderTargetPtr;

  private:
    RenderTargetPtr render_target;
    RenderTargetPtr depth_stencil_target;
    Viewport        viewport;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация очищающего кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class ClearFrame: virtual public IClearFrame, public BasicFrame
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    ClearFrame ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Флаги очистки кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   SetFlags (size_t clear_flags);
    size_t GetFlags () { return clear_flags; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры очистки буфера цвета
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetColor (const math::vec4f& color);
    void GetColor (math::vec4f& color);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Параметры очистки буфера попиксельного отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void          SetDepthValue   (float depth_value);
    void          SetStencilIndex (unsigned char stencil_index);
    float         GetDepthValue   () { return clear_depth_value; }
    unsigned char GetStencilIndex () { return clear_stencil_index; }

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore ();

  private:
    size_t        clear_flags;
    math::vec4f   clear_color;
    float         clear_depth_value;
    unsigned char clear_stencil_index;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовая система рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class BasicRenderer: virtual public IRenderer, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    BasicRenderer ();
    ~BasicRenderer ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t        GetFrameBuffersCount ();
    IFrameBuffer* GetFrameBuffer       (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderTarget* CreateDepthStencilBuffer (size_t width, size_t height);
    IRenderTarget* CreateRenderBuffer       (size_t width, size_t height);
    IClearFrame*   CreateClearFrame         ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление кадра в список отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddFrame (IFrame*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Количество кадров / позиция вставки следующего кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t FramesCount      ();
    void   SetFramePosition (size_t position);
    size_t GetFramePosition ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конец отрисовки / сброс отрисовки
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawFrames   ();
    void CancelFrames ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AttachListener (IRendererListener*);
    void DetachListener (IRendererListener*);

  private:
    typedef xtl::com_ptr<BasicFrame>        FramePtr;
    typedef stl::list<FramePtr>             FrameList;
    typedef xtl::com_ptr<FrameBuffer>       FrameBufferPtr;
    typedef stl::vector<FrameBufferPtr>     FrameBufferArray;
    typedef stl::vector<IRendererListener*> ListenerArray;

  private:
    FrameBufferPtr      frame_buffer;
    ListenerArray       listeners;
    FrameList           frames;
    FrameList::iterator frame_position;
    size_t              frames_count;
    size_t              frame_id;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочный драйвер системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class Driver: virtual public IDriver, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Driver  ();
    ~Driver ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание драйвера
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных систем визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t      GetRenderersCount ();    
    const char* GetRendererName   (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание устройства визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderer* CreateRenderer (const char* name);    
};

namespace renderer2d
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///Двумерная текстура
///////////////////////////////////////////////////////////////////////////////////////////////////
class Texture: virtual public mid_level::renderer2d::ITexture, public RenderTarget
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Texture  (size_t width, size_t height, PixelFormat format);
    Texture  (size_t width, size_t height, const char* format);
    ~Texture ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование образа текстуры в картинку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CaptureImage (media::Image&);    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update (media::Image&);

  private:
    bool        is_compressed;
    PixelFormat format;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Примитив
///////////////////////////////////////////////////////////////////////////////////////////////////
class Primitive: virtual public mid_level::renderer2d::IPrimitive, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Primitive  ();
    ~Primitive ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица преобразований
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetTransform (const math::mat4f&);
    void GetTransform (math::mat4f&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка базовой текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                             SetTexture (mid_level::renderer2d::ITexture*);
    mid_level::renderer2d::ITexture* GetTexture ();
    size_t                           GetTextureId () { return texture ? texture->Id () : 0; }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим шейдинга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                                      SetShaderMode (render::mid_level::renderer2d::ShaderMode mode);
    render::mid_level::renderer2d::ShaderMode GetShaderMode ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Режим смешивания цветов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                             SetBlendMode (mid_level::renderer2d::BlendMode blend_mode);
    mid_level::renderer2d::BlendMode GetBlendMode ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка параметра для работы альфа-теста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetAlphaReference (float ref);
    float GetAlphaReference (); 

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область отсечения
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetScissor      (const Viewport&);
    void SetScissorState (bool state);
    void GetScissor      (Viewport&);
    bool GetScissorState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Спрайты
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetSpritesCount  ();
    void   AddSprites       (size_t sprites_count, const mid_level::renderer2d::Sprite* sprites);
    void   AddSprites       (size_t sprites_count, const mid_level::renderer2d::SpriteVertex* verts);
    void   RemoveAllSprites ();
    void   ReserveSprites   (size_t sprites_count);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение вершин спрайта
///////////////////////////////////////////////////////////////////////////////////////////////////
    const mid_level::renderer2d::SpriteVertex* Vertices () const;

  private:
    typedef stl::vector<mid_level::renderer2d::SpriteVertex> SpriteArray;
    typedef xtl::com_ptr<Texture>                            TexturePtr;

  private:
    math::mat4f                       transform;
    TexturePtr                        texture;
    mid_level::renderer2d::BlendMode  blend_mode;
    mid_level::renderer2d::ShaderMode shader_mode;
    float                             alpha_reference;
    SpriteArray                       vertices;
    Viewport                          scissor_rect;
    bool                              scissor_state;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Кадр 2D визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
class Frame: virtual public mid_level::renderer2d::IFrame, public BasicFrame
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Frame  ();
    ~Frame ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Матрица вида / матрица преобразования
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewPoint  (const math::vec3f&);
    void SetProjection (const math::mat4f&);
    void GetViewPoint  (math::vec3f&);
    void GetProjection (math::mat4f&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Примитивы
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t PrimitivesCount ();
    void   AddPrimitive    (mid_level::renderer2d::IPrimitive*);
    void   Clear           ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация визуализации
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore ();

  private:
    typedef xtl::com_ptr<Primitive>   PrimitivePtr;
    typedef stl::vector<PrimitivePtr> PrimitiveArray;

  private:
    math::vec3f    view_point;
    math::mat4f    proj_tm;
    PrimitiveArray primitives;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Система рендеринга 2D-примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
class Renderer: virtual public mid_level::renderer2d::IRenderer, public BasicRenderer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Renderer  ();
    ~Renderer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    mid_level::renderer2d::ITexture*   CreateTexture   (const media::Image& image);
    mid_level::renderer2d::ITexture*   CreateTexture   (const media::CompressedImage& image);
    mid_level::renderer2d::ITexture*   CreateTexture   (size_t width, size_t height, PixelFormat pixel_format);
    mid_level::renderer2d::IPrimitive* CreatePrimitive ();
    mid_level::renderer2d::IFrame*     CreateFrame     ();
};

}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Уnилиты
///////////////////////////////////////////////////////////////////////////////////////////////////
media::PixelFormat get_image_format (PixelFormat format);        //получение эквивалента формата
PixelFormat        get_format       (media::PixelFormat format); //получение эквивалента формата

}

}

}

#endif

