#ifndef RENDER_GL_DRIVER_RENDER_TARGET_MANAGER_SWAP_CHAIN_MANAGER_SHARED_HEADER
#define RENDER_GL_DRIVER_RENDER_TARGET_MANAGER_SWAP_CHAIN_MANAGER_SHARED_HEADER

#include "../shared.h"

#include <shared/platform.h>

namespace render
{

namespace low_level
{

namespace opengl
{

//forward declarations
class SwapChainFrameBuffer;
class SwapChainColorBuffer;
class SwapChainDepthStencilBuffer;

typedef xtl::com_ptr<SwapChainColorBuffer>        ColorBufferPtr;
typedef xtl::com_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainFrameBufferManager: public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainFrameBufferManager  (const ContextManager& manager, ISwapChain* default_swap_chain);
    ~SwapChainFrameBufferManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание целевых буферов вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* CreateRenderBuffer       (const TextureDesc&);
    ITexture* CreateColorBuffer        (ISwapChain* swap_chain, unsigned int buffer_index);
    ITexture* CreateDepthStencilBuffer (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание буферов кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    static bool          IsSupported       (View* color_view, View* depth_stencil_view);
           IFrameBuffer* CreateFrameBuffer (View* color_view, View* depth_stencil_view);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение теневых буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    ColorBufferPtr        GetShadowBuffer  (SwapChainDepthStencilBuffer*);
    DepthStencilBufferPtr GetShadowBuffer  (SwapChainColorBuffer*);
    void                  GetShadowBuffers (ColorBufferPtr&, DepthStencilBufferPtr&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка активного буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFrameBuffer (ISwapChain* swap_chain, GLenum buffer_type, unsigned int frame_buffer_id, size_t cache_id);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание теневых буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    ColorBufferPtr        CreateShadowColorBuffer        (SwapChainDepthStencilBuffer*);
    DepthStencilBufferPtr CreateShadowDepthStencilBuffer (SwapChainColorBuffer*);

  private:
    typedef xtl::trackable_ptr<SwapChainColorBuffer>        ColorBufferTrackablePtr;
    typedef xtl::trackable_ptr<SwapChainDepthStencilBuffer> DepthStencilBufferTrackablePtr;
    typedef xtl::com_ptr<ISwapChain>                        SwapChainPtr;

  private:
    SwapChainPtr                   default_swap_chain;          //цепочка обмена по умолчанию    
    ColorBufferTrackablePtr        shadow_color_buffer;         //теневой буфер цвета
    DepthStencilBufferTrackablePtr shadow_depth_stencil_buffer; //теневой буфер попиксельного отсечения
};

typedef xtl::com_ptr<SwapChainFrameBufferManager> FrameBufferManagerPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер рендеринга цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainRenderBuffer: public RenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Цепочка обмена / идентификатор буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    ISwapChain*  GetSwapChain          () const { return swap_chain.get (); }
    unsigned int GetFrameBufferId      () const { return frame_buffer_id; }
    size_t       GetFrameBufferCacheId () const { return frame_buffer_cache_id; }

  protected:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainRenderBuffer (const FrameBufferManagerPtr&, RenderTargetType target_type, ISwapChain* swap_chain);
    SwapChainRenderBuffer (const FrameBufferManagerPtr&, ISwapChain* swap_chain, const TextureDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка активного буфера кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFrameBuffer (GLenum buffer_type);

  private:
    typedef xtl::com_ptr<ISwapChain> SwapChainPtr;    

  private:
    FrameBufferManagerPtr frame_buffer_manager;              //менеджер буферов кадра
    SwapChainPtr          swap_chain;                        //цепочка обмена
    unsigned int          frame_buffer_id;                   //буфер кадра
    size_t                frame_buffer_cache_id;             //идентификатор цепочки обмена
    xtl::auto_connection  swap_chain_size_change_connection; //соединение оповещения о изменении размеров цепочки обмена
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер цвета цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainColorBuffer: public SwapChainRenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainColorBuffer (const FrameBufferManagerPtr&, ISwapChain* swap_chain, unsigned int buffer_index);
    SwapChainColorBuffer (const FrameBufferManagerPtr&, ISwapChain* swap_chain, const TextureDesc& desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Номер буфера / тип буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned int GetBufferIndex () const { return buffer_index; }
    GLenum       GetBufferType  () const { return buffer_type; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Является ли буфер теневым
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsShadow () const { return is_shadow; }

  private:
    void Bind ();

  private:
    unsigned int buffer_index; //индекс буфера обмена в цепочке обмена
    GLenum       buffer_type;  //тип буфера
    bool         is_shadow;    //является ли буфер теневым
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер попиксельного отсечения цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainDepthStencilBuffer: public SwapChainRenderBuffer
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainDepthStencilBuffer  (const FrameBufferManagerPtr&, ISwapChain* swap_chain);
    SwapChainDepthStencilBuffer  (const FrameBufferManagerPtr&, ISwapChain* swap_chain, const TextureDesc&);
    ~SwapChainDepthStencilBuffer ();

  private:
    void Bind ();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Буфер попиксельного отсечения, необходимый для сочетания с буферами цвета
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainFakeDepthStencilBuffer: virtual public ITexture, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainFakeDepthStencilBuffer  (const ContextManager&, const TextureDesc&);
    ~SwapChainFakeDepthStencilBuffer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (TextureDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с данными
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetData (unsigned int layer, unsigned int mip_level, unsigned int x, unsigned int y, unsigned int width, unsigned int height, PixelFormat source_format, const void* buffer, IDeviceContext*);
    void GetData (unsigned int layer, unsigned int mip_level, unsigned int x, unsigned int y, unsigned int width, unsigned int height, PixelFormat target_format, void* buffer, IDeviceContext*);

  private:
    TextureDesc desc; //дескриптор текстуры
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Реализация буфера кадра для цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainFrameBuffer: public IFrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainFrameBuffer (const FrameBufferManagerPtr&, View* color_view, View* depth_stencil_view);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InvalidateRenderTargets (unsigned int render_target_slot, const Rect& update_rect);
    void InvalidateRenderTargets (unsigned int render_target_slot);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderTargets ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Инициализация целевых отображений
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetColorView         (View*);
    void SetDepthStencilView  (View*);
    void FinishInitialization ();

  private:
    typedef xtl::com_ptr<IRenderTargetTexture>            TexturePtr;
    typedef xtl::com_ptr<SwapChainFakeDepthStencilBuffer> FakeDepthStencilBufferPtr;

    struct RenderTarget
    {
      ViewDesc                view_desc;      //дескриптор отображения
      TexturePtr              target_texture; //целевая текстура
      MipLevelDesc            mip_level_desc; //дескриптор целевого mip-уровня текстуры
      RenderTargetTextureDesc texture_desc;   //дескриптор целевой текстуры      
      
      RenderTarget ();
    };

  private:
    FrameBufferManagerPtr     frame_buffer_manager;                    //менеджер буферов кадра
    ColorBufferPtr            color_buffer;                            //буфер цвета
    DepthStencilBufferPtr     depth_stencil_buffer;                    //буфер попиксельного отсечения
    FakeDepthStencilBufferPtr fake_depth_stencil_buffer;               //вспомогательный буфер попиксельного отсечения
    RenderTarget              render_targets [RenderTargetType_Num];   //цели отрисовки
    bool                      has_texture_targets;                     //флаг, определяющий присутствие целевых текстур
    bool                      is_color_buffer_active;                  //активен ли буфер цвета
    Rect                      dirty_rect;                              //область обновления целевых текстур
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Пустой буфер кадра
///////////////////////////////////////////////////////////////////////////////////////////////////
class SwapChainNullFrameBuffer: public IFrameBuffer, public ContextObject
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    SwapChainNullFrameBuffer (const FrameBufferManagerPtr&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка буфера в контекст OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Bind ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об отрисовке в целевые буферы
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InvalidateRenderTargets (unsigned int, const Rect&) {}
    void InvalidateRenderTargets (unsigned int) {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление целевых текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateRenderTargets () {}

  private:
    FrameBufferManagerPtr frame_buffer_manager;
};

}

}

}

#endif
