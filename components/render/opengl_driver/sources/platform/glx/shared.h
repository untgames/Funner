#ifndef RENDER_GL_DRIVER_GLX_SHARED_HEADER
#define RENDER_GL_DRIVER_GLX_SHARED_HEADER

#include <dlfcn.h>

#include <stl/algorithm>
#include <stl/auto_ptr.h>
#include <stl/hash_map>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/intrusive_ptr.h>

#include <common/singleton.h>
#include <common/strlib.h>

#include <syslib/window.h>
#include <syslib/platform/x11.h>

#include <render/low_level/utils.h>

#include <shared/log.h>
#include <shared/object.h>
#include <shared/platform.h>
#include <shared/property_list.h>

#ifndef NO_XRAND
#define HAS_XRANDR
#endif

#ifndef NO_X86VMODE
#define HAS_X86VMODE
#endif

/* Xlib.h is the default header that is included and has the core functionallity */
#include <X11/Xlib.h>
#include <X11/Xutil.h>

/* X RandR is used to configure which display ports are enabled (e.g. LCD, VGA and DVI), 
 * and to configure display modes and properties such as orientation, reflection and DPI.
 */
#ifdef HAS_XRANDR
#include <X11/extensions/Xrandr.h>
#endif

/* The XF86 Video Mode extension allows us to change the displaymode of the server
 * this allows us to set the display to fullscreen and also read videomodes and   
 * other information.                                                             
 */  
#ifdef HAS_X86VMODE
#include <X11/extensions/xf86vmode.h>
#endif

#include <shared/gl.h>
#include <shared/profile/gl/glx_types.h>

#include "glx_entries.h"

namespace render
{

namespace low_level
{

namespace opengl
{

namespace glx
{

//forward declarations
class Adapter;
class DynamicLibrary;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Pixel format descriptor
///////////////////////////////////////////////////////////////////////////////////////////////////
struct PixelFormatDesc
{
  Adapter*                    adapter;                 //adapter which supports described format
  const GlxExtensionsEntries* glx_extensions_entries;  //GLX-extensions table (must be copied inside method recieving PixelFormatDesc, may be 0)
  GLXFBConfig                 config;                  //GLX-framebuffer configuration
  int                         pixel_format_index;      //GLX-framebuffer config number
  int                         visual_id;               //
  size_t                      color_bits;              //color bits count
  size_t                      alpha_bits;              //alpha bits count
  size_t                      depth_bits;              //depth bits count
  size_t                      stencil_bits;            //stencil bits count
  size_t                      samples_count;           //samples count (0=multisample off)
  size_t                      buffers_count;           //swapchain buffers count (0=default 2 buffers)
  SwapMethod                  swap_method;             //swapchain buffer change method
  size_t                      aux_buffers;             //aux draw buffers count
  size_t                      max_pbuffer_width;       //PBuffer max width
  size_t                      max_pbuffer_height;      //PBuffer max height
  size_t                      max_pbuffer_pixels;      //PBuffer max pixels count
  bool                        support_stereo;          //stereo-rendering support
  bool                        support_draw_to_window;  //draw to Window support
  bool                        support_draw_to_pbuffer; //draw to PBuffer support
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Output device
///////////////////////////////////////////////////////////////////////////////////////////////////
class Output: virtual public IOutput, public Object
{
  public:
    typedef xtl::com_ptr<Output> Pointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Constructor / destructor
///////////////////////////////////////////////////////////////////////////////////////////////////    
    Output  (Display* display, int screen_number);
    ~Output ();    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get name
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get screen number
///////////////////////////////////////////////////////////////////////////////////////////////////
    int GetScreenNumber ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get output modes list
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetModesCount ();
    void   GetModeDesc   (size_t mode_index, OutputModeDesc& mode_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Set current output mode
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetCurrentMode (const OutputModeDesc&);
    void GetCurrentMode (OutputModeDesc&);
    void RestoreDefaultMode ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Gamma correction control
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetGammaRamp (const Color3f table [256]);
    void GetGammaRamp (Color3f table [256]);
    
  private:
    Output (const Output&); //no impl
    Output& operator = (const Output&); //no impl
    
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Class, which incapsulates work with low-level output devices
///////////////////////////////////////////////////////////////////////////////////////////////////
class OutputManager
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Constructor / destructor
///////////////////////////////////////////////////////////////////////////////////////////////////
    OutputManager  ();
    ~OutputManager ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Enumerate available output devices
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t  GetOutputsCount () const;
    Output* GetOutput       (size_t index) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Find output devices which covers max part of  window
///////////////////////////////////////////////////////////////////////////////////////////////////
    Output* FindContainingOutput (Window window) const;

  private:
    OutputManager (const OutputManager&); //no impl
    OutputManager& operator = (const OutputManager&); //no impl

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Context lost event listener
///////////////////////////////////////////////////////////////////////////////////////////////////
class IContextLostListener
{
  public:
    virtual void OnLostCurrent () = 0;

  protected:
    virtual ~IContextLostListener () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Loadable OpenGL library
///////////////////////////////////////////////////////////////////////////////////////////////////
class AdapterLibrary: virtual public ILibrary, public xtl::reference_counter
{
  public:
    typedef xtl::intrusive_ptr<AdapterLibrary> Pointer;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Load library
///////////////////////////////////////////////////////////////////////////////////////////////////
    static Pointer LoadLibrary (const char* path);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Destructor
///////////////////////////////////////////////////////////////////////////////////////////////////
    ~AdapterLibrary ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Path to library
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Work with render area
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLXPbuffer CreatePbuffer  (Display *dpy, GLXFBConfig config, const int *attrib_list); //create offscreen render area
    void       DestroyPbuffer (Display *dpy, GLXPbuffer pbuf);                            //destroy offscreen render area

///////////////////////////////////////////////////////////////////////////////////////////////////
///Create and destroy context
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLXContext CreateContext (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct); //create new GLX-rendering context
    void       DestroyContext (Display *dpy, GLXContext ctx); //destroy GLX-rendering context

///////////////////////////////////////////////////////////////////////////////////////////////////
///Set current context
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool MakeCurrent (Display *dpy, GLXDrawable drawable, GLXContext ctx, IContextLostListener* = 0);
                              
///////////////////////////////////////////////////////////////////////////////////////////////////
///Get current context and drawable
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLXContext  GetCurrentContext      (); //get current context
    GLXDrawable GetCurrentDrawable     (); //get current drawable area
    GLXDrawable GetCurrentReadDrawable (); //get current drawable area for reading
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Framebuffer configuration
///////////////////////////////////////////////////////////////////////////////////////////////////
    //get information about GLX-framebuffer configuraton
    int GetFBConfigAttrib (Display *dpy, GLXFBConfig config, int attribute, int *value); 
    
    //get list of all GLX-framebuffer configurations for given screen
    GLXFBConfig* GetFBConfigs (Display *dpy, int screen, int *nelements);
    
    //get list of all GLX-framebuffer configuration, which confirms with given attributes
    GLXFBConfig* ChooseFBConfig (Display *dpy, int screen, int *attrib_list, int *nelements);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Swap front and back buffers
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SwapBuffers (Display *dpy, GLXDrawable drawable);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Get list of supported extensions
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetExtensionsString (Display *dpy, int screen);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Get entry point address
///////////////////////////////////////////////////////////////////////////////////////////////////
    void* GetProcAddress (const char* name, unsigned int search_flags);

  private:
    AdapterLibrary (stl::auto_ptr<DynamicLibrary>&);
    
  private:
    AdapterLibrary (const AdapterLibrary&);             //no impl
    AdapterLibrary& operator = (const AdapterLibrary&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

typedef xtl::intrusive_ptr<AdapterLibrary> AdapterLibraryPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Adapter
///////////////////////////////////////////////////////////////////////////////////////////////////
class Adapter: virtual public IAdapter, public Object
{
  friend class Output;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Constructor / destructor
///////////////////////////////////////////////////////////////////////////////////////////////////
    Adapter  (const char* name, const char* dll_path, const char* init_string);
    ~Adapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Adapter name / path / description
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName        ();
    const char* GetPath        ();
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Enumeration of available output devices
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t   GetOutputsCount ();
    IOutput* GetOutput       (size_t index);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Library
///////////////////////////////////////////////////////////////////////////////////////////////////
    AdapterLibrary& GetLibrary ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Get output device
///////////////////////////////////////////////////////////////////////////////////////////////////
    Output::Pointer GetOutputForWindow (Window window);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Enuumerate available pixel formats
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef stl::vector<PixelFormatDesc>      PixelFormatArray;
    typedef stl::vector<GlxExtensionsEntries> GlxExtensionsEntriesArray;

    void EnumPixelFormats (int screen, PixelFormatArray& pixel_formats, GlxExtensionsEntriesArray& entries);

  private:
    Adapter (const Adapter&); //no impl
    Adapter& operator = (const Adapter&); //no impl    

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///SwapChain
///////////////////////////////////////////////////////////////////////////////////////////////////
class ISwapChainImpl: virtual public ISwapChain
{
  public:
    virtual Adapter*                    GetAdapterImpl          () = 0; //get adapter implementation
    virtual Display*                    GetDisplay              () = 0; //display device for current context
    virtual Window                      GetWindow               () = 0; //render window
    virtual GLXFBConfig                 GetFBConfig             () = 0; //framebuffer configuration
    virtual const GlxExtensionsEntries& GetGlxExtensionsEntries () = 0; //get GLX-extensions table
    virtual bool                        HasVSync                () = 0; //is vsync supported

  protected:
    virtual ~ISwapChainImpl () {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Primary swapchain
///////////////////////////////////////////////////////////////////////////////////////////////////
class PrimarySwapChain: virtual public ISwapChainImpl, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Constructor / destructor
///////////////////////////////////////////////////////////////////////////////////////////////////
    PrimarySwapChain  (const SwapChainDesc& sc_desc, const PixelFormatDesc& pf_desc);
    ~PrimarySwapChain ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get adapter
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapter * GetAdapter     ();
    Adapter  * GetAdapterImpl ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Display device for current context
///////////////////////////////////////////////////////////////////////////////////////////////////
    Display * GetDisplay ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Render window
///////////////////////////////////////////////////////////////////////////////////////////////////
    Window GetWindow ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get GLX-extensions table
///////////////////////////////////////////////////////////////////////////////////////////////////
    const GlxExtensionsEntries& GetGlxExtensionsEntries ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Framebuffer configuration
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLXFBConfig GetFBConfig ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get description
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (SwapChainDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get output device with max output area coverage
///////////////////////////////////////////////////////////////////////////////////////////////////
    IOutput* GetContainingOutput ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Set / Get full-screen mode state
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFullscreenState (bool state);
    bool GetFullscreenState ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Is vsync supported
///////////////////////////////////////////////////////////////////////////////////////////////////    
    bool HasVSync ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Swap front and back buffers
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Present ();    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Output device properties list
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();
    
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///PBuffer
///////////////////////////////////////////////////////////////////////////////////////////////////
class PBuffer: virtual public ISwapChainImpl, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Constructor / destructor
///////////////////////////////////////////////////////////////////////////////////////////////////
    PBuffer  (PrimarySwapChain* primary_swap_chain, size_t width, size_t height);
    PBuffer  (PrimarySwapChain* swap_chain);
    ~PBuffer ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Get adapter
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapter* GetAdapter ();
    Adapter*  GetAdapterImpl ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get description
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (SwapChainDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get output device with max output area coverage
///////////////////////////////////////////////////////////////////////////////////////////////////
    IOutput* GetContainingOutput ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Set / get full-screen mode state
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFullscreenState (bool state);
    bool GetFullscreenState ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Is vsync supported
///////////////////////////////////////////////////////////////////////////////////////////////////    
    bool HasVSync () { return false; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Swap front and back buffers
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Present ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Display device for current context
///////////////////////////////////////////////////////////////////////////////////////////////////
    Display* GetDisplay ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Render window
///////////////////////////////////////////////////////////////////////////////////////////////////
    Window GetWindow ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get GLX-extensions table
///////////////////////////////////////////////////////////////////////////////////////////////////
    const GlxExtensionsEntries& GetGlxExtensionsEntries ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Framebuffer configuration
///////////////////////////////////////////////////////////////////////////////////////////////////
    GLXFBConfig GetFBConfig ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Context
///////////////////////////////////////////////////////////////////////////////////////////////////
class Context: virtual public IContext, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Constructor / destructor
///////////////////////////////////////////////////////////////////////////////////////////////////
    Context  (ISwapChain* swap_chain);
    ~Context ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Set current context
///////////////////////////////////////////////////////////////////////////////////////////////////
    void MakeCurrent (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Check compatibility with swapchain
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsCompatible (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get OpenGL library interface
///////////////////////////////////////////////////////////////////////////////////////////////////
    AdapterLibrary& GetLibrary ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Subscribe for context events
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AttachListener (IContextListener*);
    void DetachListener (IContextListener*);

  private:
    Context (const Context&); //no impl
    Context& operator = (const Context&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Get screen and screen number
///////////////////////////////////////////////////////////////////////////////////////////////////
int     get_screen_number (Window window);
Screen* get_screen        (Window window);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Error check
///////////////////////////////////////////////////////////////////////////////////////////////////
void check_errors (const char* source);
void raise_error  (const char* source);

using syslib::x11::DisplayManager;

///////////////////////////////////////////////////////////////////////////////////////////////////
///X11 display connection lock
///////////////////////////////////////////////////////////////////////////////////////////////////
class DisplayLock
{
  public:
    DisplayLock () : display ((Display*)DisplayManager::DisplayHandle ())
    {
      if (!display)
        throw xtl::format_operation_exception ("render::low_level::opengl::glx::DisplayLock::DisplayLock()", "Can't obtain display handle");

      XLockDisplay (display);
    }
  
    DisplayLock (Display* in_display) : display (in_display)
    {
      if (!display)
        throw xtl::make_null_argument_exception ("render::low_level::opengl::glx::DisplayLock::DisplayLock(Display*)", "display");

      XLockDisplay (display);
    }

    ~DisplayLock ()
    {
      XUnlockDisplay (display);
    }

  private:
    Display* display;
};

}

}

}

}

#endif
