#ifndef RENDER_GL_DRIVER_EGL_SHARED_HEADER
#define RENDER_GL_DRIVER_EGL_SHARED_HEADER

#include <stl/algorithm>
#include <stl/auto_ptr.h>
#include <stl/hash_map>
#include <stl/vector>

#include <xtl/bind.h>
#include <xtl/intrusive_ptr.h>

#include <common/singleton.h>
#include <common/strlib.h>

#ifdef TABLETOS
  #include <syslib/window.h>
  #include <screen/screen.h>
#endif

#ifdef ANDROID
  #include <jni.h>
  #include <dlfcn.h>
  
  #include <xtl/type_traits>    
#endif

#include <shared/log.h>
#include <shared/object.h>
#include <shared/platform.h>
#include <shared/property_list.h>

#include <common/time.h>

#ifdef _WIN32
  #include <windows.h>
  
//  HDC WINAPI GetDC (HWND hwnd);  
//  int WINAPI ReleaseDC (HWND hwnd, HDC hdc);
//  int WINAPI GetWindowTextA (HWND hWnd, LPSTR lpString, int nMaxCount);
#endif

#ifdef LINUX
  #include <dlfcn.h>

  #include <syslib/platform/x11.h>
#endif

#include <EGL/egl.h>

#ifdef OPENGL_ES_SUPPORT
  #include <GLES/gl.h>
#endif

#ifdef OPENGL_ES2_SUPPORT
  #include <GLES2/gl2.h>
#endif

namespace render
{

namespace low_level
{

namespace opengl
{

namespace egl
{

//forward declarations
class Adapter;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип ускорения
///////////////////////////////////////////////////////////////////////////////////////////////////
enum Acceleration
{
  Acceleration_No,   //программный рендеринг
  Acceleration_Slow, //частичное ускорение / программная эмуляция
  Acceleration_Full, //полное ускорение через клиентский драйвер
  
  Acceleration_Num
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Дексриптор формата пикселей
///////////////////////////////////////////////////////////////////////////////////////////////////
struct PixelFormatDesc
{
  EGLConfig     egl_config;     //индекс формата пикселей в таблице форматов адаптера
  Acceleration  acceleration;   //тип ускорения формата пикселей
  size_t        color_bits;     //количество бит на цвет
  size_t        alpha_bits;     //количество бит на альфу
  size_t        depth_bits;     //количество бит на глубину
  size_t        stencil_bits;   //количество бит на трафарет
  size_t        samples_count;  //количество sample'ов (0=multisample off)
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Устройство вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class Output: virtual public IOutput, public Object
{
  public:
    typedef xtl::com_ptr<Output> Pointer;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////    
    Output  (Adapter*, const void* window_handle);
    ~Output ();    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение имени
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение списка видео-режимов
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetModesCount ();
    void   GetModeDesc   (size_t mode_index, OutputModeDesc& mode_desc);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего видео-режима
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetCurrentMode (const OutputModeDesc&);
    void GetCurrentMode (OutputModeDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление гамма-коррекцией
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetGammaRamp (const Color3f table [256]);
    void GetGammaRamp (Color3f table [256]);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение параметров
///////////////////////////////////////////////////////////////////////////////////////////////////
    EGLDisplay        GetEglDisplay   ();
    NativeDisplayType GetDisplay      ();
    const void*       GetWindowHandle ();

  private:
    Output (const Output&); //no impl
    Output& operator = (const Output&); //no impl
    
  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека функций OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
class Library: public ILibrary, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Library  ();
    ~Library ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение адреса точки входа
///////////////////////////////////////////////////////////////////////////////////////////////////
    void* GetProcAddress (const char* name, unsigned int search_flags);

  private:
    Library (const Library&); //no impl
    Library& operator = (const Library&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Адаптер
///////////////////////////////////////////////////////////////////////////////////////////////////
class Adapter: virtual public IAdapter, public Object
{
  friend class Output;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Adapter  ();
    ~Adapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя адаптера / путь к модулю / описание
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* GetName        ();
    const char* GetPath        ();
    const char* GetDescription ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных устройств вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t   GetOutputsCount ();
    IOutput* GetOutput       (size_t index);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Библиотека
///////////////////////////////////////////////////////////////////////////////////////////////////
    ILibrary& GetLibrary ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Запрос устройства вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    Output::Pointer GetOutput (const void* window_handle);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перечисление доступных форматов пикселей
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef stl::vector<PixelFormatDesc> PixelFormatArray;

    void EnumPixelFormats (EGLDisplay display, PixelFormatArray& pixel_formats);

  private:
    Adapter (const Adapter&); //no impl
    Adapter& operator = (const Adapter&); //no impl
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация устройства вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void RegisterOutput   (Output*);
    void UnregisterOutput (Output*);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Первичная цепочка обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
class PrimarySwapChain: virtual public SwapChain, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    PrimarySwapChain  (Adapter* adapter, const SwapChainDesc& desc);
    ~PrimarySwapChain ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение адаптера
///////////////////////////////////////////////////////////////////////////////////////////////////
    IAdapter* GetAdapter ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение дескриптора
///////////////////////////////////////////////////////////////////////////////////////////////////
    void GetDesc (SwapChainDesc&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение устройства вывода с максимальным размером области перекрытия
///////////////////////////////////////////////////////////////////////////////////////////////////
    IOutput* GetContainingOutput ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / взятие состояния full-screen mode
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetFullscreenState (bool state);
    bool GetFullscreenState ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен текущего заднего буфера и переднего буфера
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Present ();    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список свойств устройства вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IPropertyList* GetProperties ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение EGL параметров цепочки обмена
///////////////////////////////////////////////////////////////////////////////////////////////////
    EGLDisplay        GetEglDisplay ();
    EGLConfig         GetEglConfig  ();
    EGLSurface        GetEglSurface ();
    NativeDisplayType GetDisplay    ();

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Контекст
///////////////////////////////////////////////////////////////////////////////////////////////////
class Context: virtual public IContext, public Object
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Context  (ISwapChain* swap_chain);
    ~Context ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего контектса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void MakeCurrent (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка совместимости цепочки обмена с контекстом
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsCompatible (ISwapChain* swap_chain);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение интерфейса библиотеки OpenGL
///////////////////////////////////////////////////////////////////////////////////////////////////
    ILibrary& GetLibrary ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подписка на события контекста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AttachListener (IContextListener*);
    void DetachListener (IContextListener*);

  private:
    Context (const Context&); //no impl
    Context& operator = (const Context&); //no impl

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка ошибок
///////////////////////////////////////////////////////////////////////////////////////////////////
void        check_errors      (const char* source);
void        raise_error       (const char* source);
const char* get_error_message (EGLint status);

#ifdef BEAGLEBOARD

using syslib::x11::DisplayManager;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блокировка соединения X11
///////////////////////////////////////////////////////////////////////////////////////////////////
class DisplayLock
{
  public:
    DisplayLock () : display ((Display*)DisplayManager::DisplayHandle ())
    {
      XLockDisplay (display);    
    }
  
    DisplayLock (NativeDisplayType in_display) : display ((Display*)in_display)
    {
      XLockDisplay (display);
    }

    ~DisplayLock ()
    {
      XUnlockDisplay (display);
    }

  private:
    Display* display;
};

#else

///////////////////////////////////////////////////////////////////////////////////////////////////
///Блокировка соединения
///////////////////////////////////////////////////////////////////////////////////////////////////
class DisplayLock
{
  public:
    DisplayLock () {}
    DisplayLock (NativeDisplayType) {}
};

#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
///EGL поверхность
///////////////////////////////////////////////////////////////////////////////////////////////////
class EglSurface: public xtl::noncopyable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    EglSurface  (EGLDisplay display, EGLConfig config, const void* window_handle);
    ~EglSurface ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Поверхность
///////////////////////////////////////////////////////////////////////////////////////////////////
    EGLSurface GetSurface () const;

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Настройка окона (для TabletOS)
///////////////////////////////////////////////////////////////////////////////////////////////////
void setup_window (const void* window_handle, const SwapChainDesc& desc, Log& log);

}

}

}

}

#endif
