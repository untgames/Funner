#ifndef RENDER_SCENE_RENDER_HEADER
#define RENDER_SCENE_RENDER_HEADER

#include <stl/auto_ptr.h>
#include <xtl/functional_fwd>

#include <sg/camera.h>
#include <sg/screen.h>

namespace media
{

//forward declaration
class Image;
class FontLibrary;

}

namespace render
{

namespace scene
{

namespace client
{

///forward declarations
class RenderTargetImpl;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цель рендеринга сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTarget
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор / присваивание
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTarget  ();
    RenderTarget  (const RenderTarget&);
    ~RenderTarget ();

    RenderTarget& operator = (const RenderTarget&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Экран (политика владения - weak-ref)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetScreen (scene_graph::Screen* screen);
    scene_graph::Screen* Screen    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка связи цели рендеринга с рендером
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool IsBindedToRenderer () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Захват изображения (screen-shot)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void CaptureImage (media::Image&);
    void CaptureImage (const char* image_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (RenderTarget&);

  protected:
    RenderTarget (RenderTargetImpl*);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (RenderTarget&, RenderTarget&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Клиент рендеринга сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class Client
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Client  (const char* connection_name, const char* init_string = "", size_t logon_timeout_ms = size_t (-1));
    Client  (const Client&);
    ~Client ();
    
    Client& operator = (const Client&);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* Description () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTarget CreateRenderTarget (const char* target_name, const char* init_string = "");

///////////////////////////////////////////////////////////////////////////////////////////////////
///Максимальный уровень вложенности рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void   SetMaxDrawDepth (size_t level);
    size_t MaxDrawDepth    () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ресурсами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource   (const char* file_name);
    void UnloadResource (const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение библиотеки шрифтов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AttachFontLibrary      (const media::FontLibrary&);
    void DetachFontLibrary      (const media::FontLibrary&);
    void DetachAllFontLibraries ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ожидание незавершенных операций
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Finish ();
    void Finish    (size_t timeout_ms);
    bool TryFinish (size_t timeout_ms);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (Client&);

  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
void swap (Client&, Client&);

}

}

using scene::client::RenderTarget;
using scene::client::Client;

}

#endif
