#ifndef SCENE_GRAPH_RENDER2D_HEADER
#define SCENE_GRAPH_RENDER2D_HEADER

#include <stl/hash_map>

#include <xtl/common_exceptions.h>
#include <xtl/function.h>
#include <xtl/reference_counter.h>
#include <xtl/intrusive_ptr.h>
#include <xtl/connection.h>
#include <xtl/bind.h>
#include <xtl/visitor.h>
#include <xtl/iterator.h>
#include <xtl/token_parser.h>
#include <xtl/trackable.h>

#include <common/component.h>
#include <common/strlib.h>

#include <media/image.h>
#include <media/font.h>
#include <media/rfx/material_library.h>
#include <media/rfx/sprite_material.h>

#include <sg/camera.h>
#include <sg/scene.h>
#include <sg/sprite.h>
#include <sg/text_line.h>

#include <render/mid_level/renderer2d.h>

#include <render/custom_render.h>

namespace render
{

namespace render2d
{

//forward declaration
class Render;

typedef mid_level::renderer2d::IPrimitive  IPrimitive;
typedef mid_level::renderer2d::IRenderer   IRenderer;
typedef mid_level::renderer2d::IFrame      IFrame;
typedef mid_level::renderer2d::ITexture    ITexture;
typedef mid_level::IRenderTarget           IRenderTarget;
typedef mid_level::renderer2d::BlendMode   BlendMode;
typedef xtl::com_ptr<IPrimitive>           PrimitivePtr;
typedef xtl::com_ptr<IRenderer>            RendererPtr;
typedef xtl::com_ptr<IFrame>               FramePtr;
typedef xtl::com_ptr<ITexture>             TexturePtr;
typedef xtl::com_ptr<IRenderTarget>        RenderTargetPtr;
typedef xtl::com_ptr<IRenderQuery>         RenderQueryPtr;
typedef media::rfx::SpriteMaterial         SpriteMaterial;
typedef SpriteMaterial::Pointer            SpriteMaterialPtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый визуализируемый объект
///////////////////////////////////////////////////////////////////////////////////////////////////
class Renderable: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
            Renderable  (scene_graph::Entity*);
    virtual ~Renderable () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw (IFrame& frame);

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение об изменениях в объекте
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Update () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void DrawCore (IFrame& frame) = 0;

  private:
    void UpdateNotify ();

  private:
    xtl::auto_connection on_update_connection;  //соединение на сигнал оповещения об обновлении объекта
    bool                 need_update;           //флаг необходимости обновления внутренних структур данных объекта
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Модель, состоящая из спрайтов
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableSpriteModel: public Renderable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableSpriteModel (scene_graph::SpriteModel* model, Render& render);
    ~RenderableSpriteModel ();

  private:
    void Update ();
    void DrawCore (IFrame&);

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подготовленные к рендерингу шрифт
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableFont
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableFont (const char* font_name, Render& in_render);
    ~RenderableFont ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    const media::Font& GetFont () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение текстуры
///////////////////////////////////////////////////////////////////////////////////////////////////
    ITexture* GetTexture () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение размера самой большой стороны глифа
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t GetMaxGlyphSide () const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение спрайта по индексу
///////////////////////////////////////////////////////////////////////////////////////////////////
    const render::mid_level::renderer2d::Sprite& GetSprite (size_t index) const;
      //ввести другую структуру!!!!

  private:
    typedef xtl::uninitialized_storage<render::mid_level::renderer2d::Sprite> SpritesBuffer;
    typedef xtl::com_ptr<ITexture>                                            TextuerPtr;

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Линия текста
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderableTextLine: public Renderable, public xtl::trackable
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderableTextLine (scene_graph::TextLine* text_line, Render& render);
    ~RenderableTextLine ();

  private:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обновление линии текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Update ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка нового шрифта
///////////////////////////////////////////////////////////////////////////////////////////////////
    void PreprocessFont ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование линии текста
///////////////////////////////////////////////////////////////////////////////////////////////////
    void DrawCore (IFrame&);

  private:
    typedef xtl::uninitialized_storage<render::mid_level::renderer2d::Sprite> SpritesBuffer;

  private:
    struct Impl;
    stl::auto_ptr<Impl> impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Область вывода рендера
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderView: public IRenderView, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderView  (scene_graph::Scene*, Render*);
    ~RenderView ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Целевые буферы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void           SetRenderTargets      (IRenderTarget* render_target, IRenderTarget* depth_stencil_target);
    IRenderTarget* GetRenderTarget       ();
    IRenderTarget* GetDepthStencilTarget ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetViewport (const Rect& rect);
    void GetViewport (Rect& out_rect);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка камеры
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetCamera (scene_graph::Camera*);
    scene_graph::Camera* GetCamera ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / чтение свойств
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetProperty (const char* name, const char* value);
    void GetProperty (const char* name, size_t buffer_size, char* value_buffer);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рисование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

  private:
    typedef xtl::intrusive_ptr<Render> RenderPtr;

  private:
    RenderPtr            render; //рендер
    FramePtr             frame;  //кадр
    scene_graph::Scene*  scene;  //сцена
    scene_graph::Camera* camera; //камера
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Рендер двумерной сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class Render: public ICustomSceneRender, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    Render  (mid_level::IRenderer*);
    ~Render ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание областей вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    IRenderView* CreateRenderView (scene_graph::Scene* scene);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ресурсами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource   (const char* tag, const char* file_name);
    void UnloadResource (const char* tag, const char* file_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Протоколирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void               SetLogHandler (const LogFunction&);
    const LogFunction& GetLogHandler ();

    void LogPrintf (const char* format, ...);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание дочерних запросов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                 SetQueryHandler (const QueryFunction&);
    const QueryFunction& GetQueryHandler ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddRef  ();
    void Release ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const RendererPtr& Renderer () const { return renderer; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с кэшем
///////////////////////////////////////////////////////////////////////////////////////////////////
    Renderable*     GetRenderable (scene_graph::SpriteModel*);  // дублирование!!!
    Renderable*     GetRenderable (scene_graph::TextLine*);     // дублирование!!!
    ITexture*       GetTexture    (const char* file_name, bool need_alpha, RenderQueryPtr& out_query);
    SpriteMaterial* GetMaterial   (const char* name);
    RenderableFont* GetFont       (const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление кадра на отрисовку
///////////////////////////////////////////////////////////////////////////////////////////////////
    void AddFrame (IFrame*);

  private:
    typedef xtl::intrusive_ptr<Renderable> RenderablePtr;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с кэшем примитивов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void InsertRenderable (scene_graph::Entity*, const RenderablePtr&);
    void RemoveRenderable (scene_graph::Entity*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с ресурсами
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadMaterialLibrary   (const char* file_name);
    void UnloadMaterialLibrary (const char* file_name);
    void InsertMaterial        (const char* id, const SpriteMaterialPtr&);
    void RemoveMaterial        (const char* id);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание текстур
///////////////////////////////////////////////////////////////////////////////////////////////////
    TexturePtr CreateTexture        (const char* file_name, bool need_alpha, bool& has_alpha, RenderQueryPtr& out_query);
    TexturePtr CreateDynamicTexture (const char* name, RenderQueryPtr& out_query);

  private:
    struct RenderableHolder
    {
      RenderablePtr        renderable;
      xtl::auto_connection on_destroy;

      RenderableHolder (const RenderablePtr& in_renderable)
        : renderable (in_renderable) {}
    };

    struct TextureHolder
    {
      TexturePtr     base_texture;  //базовая текстура
      TexturePtr     alpha_texture; //альфа-текстура
      RenderQueryPtr query;         //запрос дочернего рендеринга

      TextureHolder (const TexturePtr& in_base_texture, const TexturePtr& in_alpha_texture, const RenderQueryPtr& in_query) :
        base_texture (in_base_texture), alpha_texture (in_alpha_texture), query (in_query) {}
    };

    typedef stl::hash_map<scene_graph::Entity*, RenderableHolder>        RenderableMap;
    typedef stl::hash_map<stl::hash_key<const char*>, SpriteMaterialPtr> MaterialMap;
    typedef stl::hash_map<stl::hash_key<const char*>, TextureHolder>     TextureMap;

    typedef xtl::shared_ptr<RenderableFont>                              RenderableFontPtr;
    typedef stl::hash_map<stl::hash_key<const char*>, RenderableFontPtr> RenderableFontMap;

  private:
    LogFunction       log_handler;       //функция протоколирования
    QueryFunction     query_handler;     //функция создания дочерних запросов
    RendererPtr       renderer;          //система рендеринга
    RenderableMap     renderables_cache; //кэш визуализируемых объектов
    MaterialMap       materials;         //материалы
    TextureMap        textures;          //текстуры
    RenderableFontMap fonts;             //шрифты
};

}

}

#endif
