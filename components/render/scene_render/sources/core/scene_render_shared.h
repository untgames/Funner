#ifndef RENDER_SCENE_RENDER_CORE_SCENE_RENDER_SHARED_HEADER
#define RENDER_SCENE_RENDER_CORE_SCENE_RENDER_SHARED_HEADER

#include "shared.h"

namespace render
{

//forward declaration
class RenderTargetManager;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер путей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderPathManager
{
  public:
    typedef SceneRender::LogFunction LogFunction;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструкторы / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderPathManager () {}
    RenderPathManager (const char* driver_name_mask, const char* renderer_name_mask, const char* render_path_masks, const LogFunction& log_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Система рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    mid_level::IRenderer* Renderer () const { return renderer.get (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список доступных путей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* RenderPaths () const { return render_paths_string.c_str (); }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Проверка наличия пути рендеринга / получение пути рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool                HasRenderPath (const char* path_name) const;
    ICustomSceneRender& GetRenderPath (const char* path_name) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка ресурса
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LoadResource (const char* tag, const char* file_name, const LogFunction& log_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Обмен
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Swap (RenderPathManager&);

  private:
    RenderPathManager (const RenderPathManager&); //no impl
    RenderPathManager& operator = (const RenderPathManager&); //no impl

  private:
    struct RenderPath
    {
      CustomSceneRenderPtr render;  
      stl::string          name;

      RenderPath (const CustomSceneRenderPtr& in_render, const char* in_name) : render (in_render), name (in_name) {}
    };

    typedef stl::hash_map<stl::hash_key<const char*>, RenderPath> RenderPathMap;
    typedef xtl::com_ptr<mid_level::IRenderer>                    RendererPtr;    

  private:
    RendererPtr   renderer;            //система рендеринга
    RenderPathMap render_paths;        //пути рендеринга
    stl::string   render_paths_string; //строка с именами доступных путей рендеринга
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый класс для реализации цели рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class IRenderTargetImpl: public xtl::reference_counter
{
  public:  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual ~IRenderTargetImpl () {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Имена ассоциированных буферов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual const char* ColorAttachment () = 0;
    virtual const char* DepthStencilAttachment () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текущий экран
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual render::Screen* Screen () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Смена текущего экрана
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void SetScreen (render::Screen* in_screen) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////    
///Текущее логическое окно вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void        SetScreenArea (const Rect& rect) = 0;
    virtual const Rect& ScreenArea    () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Текущее физическое окно вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void        SetRenderableArea (const Rect& rect) = 0;
    virtual const Rect& RenderableArea    () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////    
///Перерисовка
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void Draw () = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////    
///Захват изображения
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void CaptureImage (media::Image&) = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о необходимости сброса ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void FlushResources () = 0;    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Менеджер целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderTargetManager: public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderTargetManager (const SceneRender::LogFunction& log_handler);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Register   (IRenderTargetImpl*);
    void Unregister (IRenderTargetImpl*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор доступных целей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t             RenderTargetsCount () { return render_targets.size (); }
    IRenderTargetImpl* RenderTarget       (size_t index);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка текущего менеджера путей рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetRenderPathManager (render::RenderPathManager*);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение системы рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    mid_level::IRenderer& Renderer ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение пути рендеринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    ICustomSceneRender& GetRenderPath (const char* render_path_name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FlushResources ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Регистрация ассоциированных целей ренедринга
///////////////////////////////////////////////////////////////////////////////////////////////////
    void                      RegisterAttachment       (const char* name, mid_level::IRenderTarget* render_target);
    void                      UnregisterAttachment     (const char* name);
    void                      UnregisterAllAttachments ();
    mid_level::IRenderTarget* GetAttachment            (const char* name);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Начало / конец транзакции отрисовки 
///////////////////////////////////////////////////////////////////////////////////////////////////
    bool BeginDraw (); //результат показывает допустимость отрисовки (введено для будущего контроля глубины вложенности рендеринга)
    void EndDraw   ();
    bool IsInDraw  () const { return draw_depth != 0; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Протоколирование
///////////////////////////////////////////////////////////////////////////////////////////////////
    void LogMessage (const char* message);

  private:
    RenderTargetManager (const RenderTargetManager&); //no impl
    RenderTargetManager& operator = (const RenderTargetManager&); //no impl

  private:
    typedef stl::vector<IRenderTargetImpl*>                          RenderTargetList;
    typedef xtl::com_ptr<mid_level::IRenderTarget>                   AttachmentPtr;
    typedef stl::hash_map<stl::hash_key<const char*>, AttachmentPtr> AttachmentMap;

  private:
    render::RenderPathManager* render_path_manager; //менеджер путей рендеринга
    RenderTargetList           render_targets;      //цели рендеринга
    AttachmentMap              attachments;         //ассоциированные цели рендеринга
    size_t                     draw_depth;          //глубина вложенности рендеринга
    SceneRender::LogFunction   log_handler;         //обработчик протоколирования
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отрисовываемая область вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
class RenderView: private IViewportListener, public xtl::reference_counter
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Интерфейс обратной связи от RenderView к RenderTarget
///////////////////////////////////////////////////////////////////////////////////////////////////
    class IRenderTargetAPI
    {
      public:
        virtual mid_level::IRenderer& GetRenderer       () = 0; //получение системы визуализации
        virtual const Rect&           GetRenderableArea () = 0; //получение физических границ области рендеринга
        virtual const Rect&           GetScreenArea     () = 0; //получение логических границ области рендеринга
        virtual ICustomSceneRender&   GetRenderPath     (const char* name) = 0; //получение пути рендеринга
        virtual void                  UpdateOrderNotify () = 0; //оповещение об обновлении порядка следования областей вывода
        virtual void                  GetRenderTargets  (mid_level::IRenderTarget*& render_target, mid_level::IRenderTarget*& depth_stencil_target) = 0; //получение ассоциированных буферов рендеринга
        
      protected:
        virtual ~IRenderTargetAPI () {}
    };  

///////////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор / деструктор
///////////////////////////////////////////////////////////////////////////////////////////////////
    RenderView  (const render::Viewport& vp, IRenderTargetAPI& render_target_api);
    ~RenderView ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Получение области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    render::Viewport& Viewport () { return viewport; }

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отрисовка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void Draw ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс ресурсов
///////////////////////////////////////////////////////////////////////////////////////////////////
    void FlushResources ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Оповещение о необходимости изменения границ области вывода
///////////////////////////////////////////////////////////////////////////////////////////////////
    void UpdateAreaNotify ();

  private:
    void UpdateRenderView   ();
    void UpdateClearFrame   ();
    void OnChangeCamera     (scene_graph::Camera*);
    void OnChangeArea       (const Rect&);
    void OnChangeRenderPath (const char*);
    void OnChangeZOrder     (int);
    void OnChangeScene      ();
    void OnChangeProperty   (const char* name, const char* value);
    void OnChangeBackground (bool state, const math::vec4f& color);
    void AddRef             ();
    void Release            ();

  private:
    typedef xtl::com_ptr<IRenderView>                    RenderViewPtr;
    typedef xtl::com_ptr<render::mid_level::IClearFrame> ClearFramePtr;

  private:
    render::Viewport      viewport;                //область вывода
    IRenderTargetAPI&     render_target_api;       //интерфейс обратной связи к RenderTarget
    RenderViewPtr         render_view;             //область рендеринга
    scene_graph::Scene*   current_scene;           //текущая сцена
    scene_graph::Camera*  current_camera;          //текущая камера
    ClearFramePtr         clear_frame;             //кадр очистки
    bool                  need_update_view;        //необходимо обновить параметры области вывода
    bool                  need_update_area;        //необходимо обновить координаты области вывода
    bool                  need_update_camera;      //необходимо обновить камеру
    bool                  need_update_path;        //необходимо обновить путь рендеринга
    bool                  need_update_clear_frame; //необходимо обновить очищающий кадр
    xtl::auto_connection  on_camera_scene_change;  //соединение с сигналом оповещения об изменении сцены в камере  
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочное протоколирование
///////////////////////////////////////////////////////////////////////////////////////////////////
void log_printf (const SceneRender::LogFunction& log_handler, const char* format, ...);

}

#endif
